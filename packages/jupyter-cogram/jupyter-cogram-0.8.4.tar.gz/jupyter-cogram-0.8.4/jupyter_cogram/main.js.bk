define([
    'jquery',
    'base/js/keyboard',
    'require',
    'base/js/namespace',
    'notebook/js/cell',
    'notebook/js/codecell',
    // 'notebook/js/completer',
    'module'
], function (
    $,
    keyboard,
    requirejs,
    Jupyter,
    cell,
    codecell,
    // completer,
    module
) {
    "use strict";

    const logPrefix = '[' + module.id + ']';
    let options = {
        suggestion_opacity: 0.5,
        suggestion_accept_delay: 600000,
        modify_query_delay: 2000,
        cursor_blink_rate: 530,
        upgrade_message_timeout: 120000,
        should_prepend_imports: true,
        auto_submit: false,
    }
    let extension_state = {
        is_open: false,
        current_choice_idx: undefined,
        choices: [],
        considering_choices: false,
        suggestionAcceptTimeout: undefined,
        version_is_up_to_date: undefined,
        queryTimeout: undefined,
        pre_cursor: undefined,
        post_cursor: undefined,
        // original_completer: undefined,
        auth_token: undefined,
        current_completion_query: undefined,
    };
    // let Cell = cell.Cell;
    let CodeCell = codecell.CodeCell;
    // let Completer = completer.Completer;

    let keycodes = keyboard.keycodes;
    let specials = [
        keycodes.enter,
        keycodes.esc,
        // keycodes.backspace,
        // keycodes.tab,
        // keycodes.up,
        // keycodes.down,
        // keycodes.left,
        // keycodes.right,
        keycodes.shift,
        keycodes.ctrl,
        keycodes.alt,
        keycodes.meta,
        keycodes.capslock,
        // keycodes.space,
        keycodes.pageup,
        keycodes.pagedown,
        keycodes.end,
        keycodes.home,
        keycodes.insert,
        keycodes.delete,
        keycodes.numlock,
        keycodes.f1,
        keycodes.f2,
        keycodes.f3,
        keycodes.f4,
        keycodes.f5,
        keycodes.f6,
        keycodes.f7,
        keycodes.f8,
        keycodes.f9,
        keycodes.f10,
        keycodes.f11,
        keycodes.f12,
        keycodes.f13,
        keycodes.f14,
        keycodes.f15
    ];

    const _get_cookie = (name) => {
        // from tornado docs: http://www.tornadoweb.org/en/stable/guide/security.html
        const r = document.cookie.match("\\b" + name + "=([^;]*)\\b");
        return r ? r[1] : undefined;
    }

    const currentCell = () => Jupyter.notebook.get_selected_cell();

    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;

    const getCursorPos = (text) => {
        const lines = text.split('\n');
        if (lines.length === 0) return [0, 0];

        const row = lines.length - 1;
        const ch = lines.slice(-1)[0].length;
        return [row, ch];
    }

    const setCursorForCell = (text) => {
        const [row, ch] = getCursorPos(text);
        // console.log(logPrefix, "Setting cursor for code", row, ch, text);
        Jupyter.notebook.get_selected_cell().code_mirror.setCursor(row, ch);
    }

    const setCmOption = (cell, option, val) => {
        cell.code_mirror.options[option] = val;
    }

    const readOnlyOff = (cell) => {
        // console.log(logPrefix, "Turned edit mode on")
        setCmOption(currentCell(), 'readOnly', false);
        // $('.notebook_app').removeClass('command_mode').addClass('edit_mode')
    }

    const readOnlyOn = () => {
        // console.log(logPrefix, "Turned edit mode on")
        setCmOption(currentCell(), 'readOnly', true);
        // $('.notebook_app').removeClass('command_mode').addClass('edit_mode')
    }

    const setSuggestionOpacity = (cell, start, end, val) => {
        let editor = cell.code_mirror;
        console.log(logPrefix, "Setting opacity from", start, "to", end, "to", val);
        editor.markText(start, end, { css: `opacity:${val};` })
        // editor.setSelection(start, end);
        if (val === 1) {
            // editor.setSelection(end, null)
        } else {
            // editor.setSelection(start, end)
        }
    }

    const getMarkTextPosition = (text) => {
        const startOfOpacity = getCursorPos(text);
        return { line: startOfOpacity[0], ch: startOfOpacity[1] };
    }

    const code_exec_callback = (query, response) => {
        let choices = response["message"]
        choices = choices.filter(choice => choice.suggestion.trim() !== "")

        if (choices.length > 0) {
            console.log(logPrefix, "Received", choices.length, "code suggestions")
            extension_state.choices = choices;
            extension_state.current_choice_idx = 0;
            insertChoice();
        } else {
            console.log(logPrefix, "Did not receive any non-empty suggestions...");
        }


    }

    const clearSuggestionAcceptTimeout = () => {
        if (extension_state.suggestionAcceptTimeout !== undefined) {
            clearTimeout(extension_state.suggestionAcceptTimeout);
        }
    }

    const getImportPrefix = () => {
        const imports = extension_state.choices[extension_state.current_choice_idx].imports;

        if (!imports) {
            console.log(logPrefix, "No imports found associated with suggestion")
            return;
        }

        console.log(logPrefix, "Found imports\n", imports);
        return imports + '\n\n';
    }
    const prependImports = (importPrefix) => {
        if (!options.should_prepend_imports || !importPrefix) {
            return;
        }

        const curr_cell = currentCell();
        const prev_content = curr_cell.get_text();

        curr_cell.set_text(importPrefix + prev_content)
    }

    const ensureEditorInsertionComplete = (cell) => {
        if (!extension_state.considering_choices) return;

        const imports = getImportPrefix();

        prependImports(imports);


        let preCursorPlusImportsCode =
            extension_state.pre_cursor +
            (imports ?? "") +
            extension_state.choices[extension_state.current_choice_idx].suggestion;

        // setCmOption(cell, 'cursorBlinkRate', options.cursor_blink_rate);
        // toEditModeAndReadOnlyOff(cell);
        // console.log(logPrefix, "Ensuring complete", preCursorPlusImportsCode)

        setCursorForCell(preCursorPlusImportsCode);

        const endOfOpacity = getMarkTextPosition(preCursorPlusImportsCode);

        console.log(logPrefix, "Setting cursor at", endOfOpacity)

        setSuggestionOpacity(cell, { line: 0, ch: 0 }, endOfOpacity, 1);

        deleteHint();
        clearConsideration();
        readOnlyOff();
        // restoreCompleter();
    }

    // const restoreCompleter = () => Jupyter.notebook.get_selected_cell().completer.startCompletion = extension_state.original_completer;

    const clearConsideration = () => {
        extension_state.considering_choices = false;
        extension_state.choices = []
        extension_state.pre_cursor = undefined
        extension_state.post_cursor = undefined
    }

    const acceptSuggestionWithDelay = (delay = options.suggestion_accept_delay) => {
        if (extension_state.suggestionAcceptTimeout)
            clearTimeout(extension_state.suggestionAcceptTimeout)

        let cur_cell = currentCell();

        extension_state.suggestionAcceptTimeout = setTimeout(() => {
            ensureEditorInsertionComplete(cur_cell);
        }, delay);
    }

    const removeWhitespace = (code, cell) => {
        const currentLine = getCurrentLine(cell);
        const [row, ch] = getCMcursorLineCh(cell);
        const cursorIsIndented = currentLine.slice(0, ch).trim() === "";

        // console.log(logPrefix, "Is cursor indented with whitespace?", cursorIsIndented);

        if (!cursorIsIndented) return code;

        // count initial whitespaces
        let splitLine = currentLine.split('');
        // console.log(logPrefix, "Have splitLine", splitLine);
        let count = 0;
        for (let i = 0; i < splitLine.length; i++) {
            if (splitLine[i] === ' ')
                count++;
            else
                break;
        }
        // console.log(logPrefix, "found", count, "initial whitespaces");

        return code.slice(count);
    }

    const insertChoice = () => {
        readOnlyOn();
        let cur_cell = currentCell();
        extension_state.current_completion_query = undefined;
        let code = extension_state.choices[extension_state.current_choice_idx].suggestion;
        // code = removeWhitespace(code, cur_cell);
        extension_state.considering_choices = true;

        displayHint();
        clearSuggestionAcceptTimeout();

        const preCursorPlusCode = extension_state.pre_cursor + code
        const newCode = preCursorPlusCode + extension_state.post_cursor

        // console.log(logPrefix, `added code '${code}'`)

        // console.log(logPrefix, `setting newCode '${newCode}'`)

        cur_cell.set_text(newCode);


        const startOfOpacity = getMarkTextPosition(extension_state.pre_cursor);
        const endOfOpacity = getMarkTextPosition(preCursorPlusCode);
        setSuggestionOpacity(cur_cell, startOfOpacity, endOfOpacity, options.suggestion_opacity);

        // toCommandModeAndReadOnly(cur_cell);
        setCursorForCell(extension_state.pre_cursor);
        // setCmOption(cur_cell, 'cursorBlinkRate', -1);

        acceptSuggestionWithDelay()
        focusCodeMirror();
    }

    const stopInsertion = () => {
        const oldCellContent = extension_state.pre_cursor + extension_state.post_cursor

        // console.log(logPrefix, "Restoring old cell contents", extension_state.pre_cursor, extension_state.post_cursor)
        currentCell().set_text(oldCellContent);

        // toEditModeAndReadOnlyOff(cur_cell);
        setCursorForCell(extension_state.pre_cursor);
        // restoreCompleter();
        clearConsideration();
        deleteHint();
        clearSuggestionAcceptTimeout();
        readOnlyOff();
    }




    const toggleSpinning = (spinningOn) => {
        if (spinningOn) {
            $("#cogram-spinner")
                .addClass('fa-spin')
                .css('color', 'orange');
        } else {
            $("#cogram-spinner")
                .removeClass('fa-spin')
                .css('color', 'green');
        }
    }

    const getPreCursor = (cell) => {
        const cursor = cell.code_mirror.getCursor();
        return cell.code_mirror.getRange({ line: 0, ch: 0 }, cursor);
    }

    const getPostCursor = (cell) => {
        const cursor = cell.code_mirror.getCursor();
        const last_line_num = cell.code_mirror.lineCount() - 1;
        const last_line_len = cell.code_mirror.getLine(last_line_num).length;
        const end = { line: last_line_num, ch: last_line_len };
        return cell.code_mirror.getRange(cursor, end);
    }
    const sendCompletionQuery = () => {
        const current_cell_index = Jupyter.notebook.get_selected_index()
        // send previous cells
        let cell_contents = Jupyter.notebook.get_cells().map(
            x => x.get_text()
        ).slice(0, current_cell_index + 1);

        cell_contents.pop();

        let curr_cell = currentCell();

        extension_state.pre_cursor = getPreCursor(curr_cell);
        extension_state.post_cursor = getPostCursor(curr_cell);

        const session_id = Jupyter.notebook.session.id;
        const kernel_id = Jupyter.notebook.kernel.id;

        const queries = [extension_state.pre_cursor,];

        let payload = {
            queries,
            'cell_contents': cell_contents,
            session_id,
            kernel_id,
            auth_token: extension_state.auth_token,
        }
        console.log(logPrefix, "Have query from cell", payload);
        const xsrf_token = _get_cookie('_xsrf')
        extension_state.current_completion_query = $.post({
            url: '/cogram',
            data: JSON.stringify(payload),
            headers: { 'X-XSRFToken': xsrf_token },
            dataType: "json",
            contentType: "application/json",
            beforeSend: function (request) {
                toggleSpinning(true);

            },
            success: function (response) {
                code_exec_callback(payload, response);
            },
            error: handle_jupyter_cogram_error,
            complete: function () {
                toggleSpinning(false);
            },
        });
    }

    const check_valid_token_exists_callback = (data) => extension_state.auth_token = data.auth_token;

    const check_valid_token_exists_error_callback = (jqXHR, textStatus, errorThrown) => {
        extension_state.auth_token = undefined;
        console.log(logPrefix, '`checkValidTokenExists` ajax error:', jqXHR, textStatus, errorThrown);
        const status = jqXHR.status;
        if (status === 500)
            return "unavailable"

        if (status == 403) {
            let error_obj = JSON.parse(jqXHR.responseText);
            console.log(logPrefix, "Returning 403 error", error_obj);
            return error_obj?.error;
        }
        return null;
    }

    const checkValidTokenExists = (logLaunch = false) => {
        const log_launch = (typeof logLaunch === "boolean") ? logLaunch : false;
        console.log(logPrefix, "Checking if valid token exists with `logLaunch`=", log_launch);
        let status = null;
        $.get({
            url: '/token',
            dataType: 'JSON',
            data: { "log_launch": log_launch },
            async: false,
            success: function (response) {
                check_valid_token_exists_callback(response);
                status = "ok";
            },
            error: function (jqXHR, textStatus, errorThrown) {
                status = check_valid_token_exists_error_callback(jqXHR, textStatus, errorThrown);
            },
        })

        console.log(logPrefix, "check completed. status", status)
        return status;
    }

    const checkIfVersionIsUpToDate = () => {
        console.log(logPrefix, "Checking if version is up to date...");
        $.get({
            url: '/checkVersion',
            dataType: 'JSON',
            async: false,
            success: function (response) {
                extension_state.version_is_up_to_date = true;
            },
            error: checkVersionUpToDateErrorCallback,
        })
    }

    const setUpgradeSpinner = () => {
        $('#upgrade_button').html(`<i class="fa fa-spinner fa-spin" aria-hidden="true"></i>`)
    };

    const upgradeButton = () => {
        let upgradeButton = `<button id="upgrade_button" class="mui-btn mui-btn--primary">Upgrade</button>`
        $('body').on('click', '#upgrade_button', () => {
            setUpgradeSpinner();
            runAutoUpgrade();
        }
        );
        return upgradeButton;
    }

    const bigLb = () => `<div style="line-height:120%;"><br></div>`;

    const checkVersionUpToDateErrorCallback = (jqXHR, textStatus, errorThrown) => {
        console.log(logPrefix, "In /checkVersion error callback")
        extension_state.version_is_up_to_date = false;
        let error_obj = JSON.parse(jqXHR.responseText);
        console.log(logPrefix, error_obj)
        let pypi_version = error_obj?.pypi_version
        const install_command = `<span style="font-family:monospace">pip install -U jupyter-cogram</span>`
        let msg = `<div class="mui--text-subhead">A new version of Jupyter Cogram is out  🎈` +
            `<span class="mui--text-body2">${bigLb()}Click here to automatically upgrade to version ${pypi_version}</span></div>` +
            upgradeButton() +
            `<span class="mui--text-body1"><br>Alternatively, you can upgrade to ` +
            `manually by running<br>${install_command} ` +
            `<br>in your terminal. Afterwards, please restart your Jupyter ` +
            `Notebook server.</span>`
        showSuccessMessage(msg, options.upgrade_message_timeout)
    }


    const submitToken = (entered_token) => {
        console.log(logPrefix, "Submitting token", entered_token);
        let success = false;
        let msg;
        $.post({
            url: '/token',
            data: JSON.stringify({ "auth_token": entered_token }),
            headers: { 'X-XSRFToken': _get_cookie('_xsrf') },
            dataType: "json",
            async: false,
            contentType: "application/json",
            success: function (response) {
                extension_state.auth_token = entered_token;
                turnExtensionOn(true);
                success = true;
            },
            error: function (jqXHR, textStatus, errorThrown) {
                let error_obj = JSON.parse(jqXHR.responseText);
                msg = `Error ${jqXHR.status}: ${error_obj['error']}`
                console.log('Have error msg from `submitToken()`', msg)
            }
        });
        console.log(logPrefix, "Token submission completed. Success?", success);
        return [success, msg];
    }

    let initialize = function () {
        console.log(logPrefix, "Initializing extension...")
        Jupyter.toolbar.add_buttons_group([
            Jupyter.keyboard_manager.actions.register({
                help: 'Launch jupyter-cogram',
                icon: 'fas fa-link',
                handler: toggle_jupyter_cogram_editor,

            }, 'create-jupyter-cogram-from-notebook', 'Cogram')
        ], 'cogram-button-group');
        let iconUrl = "https://uploads-ssl.webflow.com/61294dc1bd225d7c490b4389/6131d7249979f73249363dd0_icon_black_64.png"
        $('.fas.fa-link.fa').replaceWith(`<img id="cogram-button-logo" src="${iconUrl}" style="max-height:16px;"alt="Cogram">`);
        build_cogram_status_info();
    };

    const turnExtensionOn = (on) => {
        if (on) {
            console.log(logPrefix, "Extension is off. Turning it on.")
            $("#cogram-status").show();
            extension_state.is_open = true;
        } else {
            console.log(logPrefix, "Extension is on. Turning it off.")
            $("#cogram-status").hide();
            extension_state.is_open = false;
        }
    }

    const showInfoPanelWithContent = (infoPanelContent) => {
        infoPanelContent.attr('id', 'info-panel-content');
        console.log('Showing panel with content', infoPanelContent)
        $('#info-panel-content').remove()
        $('#jupyter-cogram-info-panel').append(infoPanelContent);
        $('#jupyter-cogram-info-panel').show();
    }

    const toggle_jupyter_cogram_editor = (logLaunch = false) => {
        if (extension_state.is_open) {
            turnExtensionOn(false);
            return;
        }
        const token_check_result = checkValidTokenExists(logLaunch);
        console.log(logPrefix, "Valid token exists:", token_check_result);
        if (token_check_result === "ok") {
            $("#jupyter-cogram-info-panel").hide();
            turnExtensionOn(true);
        }
        else if (token_check_result === "unavailable") {
            showAlertMessage(serverUnavailableMsg, 10000)
        }
        else if (token_check_result) {
            showInfoPanelWithContent(tokenInteraction(token_check_result))
        }
        else {
            showInfoPanelWithContent(tokenInteraction());
            turnExtensionOn(false);
        }
        // turnExtensionOn(extension_state.is_open ? false : true);
    }

    const getCurrentLine = (cell) => {
        const lines = cell.get_text().split('\n');
        const line_idx = cell.code_mirror.getCursor().line;
        return lines[line_idx];
    }


    const isFirstPromptCell = (cell) => {
        const text = cell.get_text();
        if (text === "") return false;

        // it's a `first prompt` cell if there's only one line
        // that starts with `##`
        const line = getCurrentLine(cell);
        return line.startsWith('## ') && line.endsWith(' #');
    }

    const isCompletePrompt = (cell) => {
        const text = cell.get_text();
        if (text === "") return false;

        // it's a complete prompt if we're modifying a line that 
        // starts and ends with hash
        const line = getCurrentLine(cell);
        return line.startsWith('## ') && line.endsWith(' ##');
    }

    function onlyModifierEvent(event) {
        const key = keyboard.inv_keycodes[event.key];
        return (
            (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) &&
            (key === 'alt' || key === 'ctrl' || key === 'meta' || key === 'shift')
        );
    }

    function isCommandPlusEvent(event) {
        return event.ctrlKey || event.metaKey;
    }

    function isLeftRightKey(event) {
        const key_code = event.which;
        return (key_code === keycodes.left) ||
            (key_code === keycodes.right);
    }

    function isUpDownKey(event) {
        const key_code = event.which;
        return (key_code === keycodes.up) ||
            (key_code === keycodes.down);
    }

    const isTabKey = (event) => event.which === keycodes.tab;
    const isBackKey = (event) => event.which === keycodes.backspace;

    const cycleThroughChoices = (is_right) => {
        const current_idx = extension_state.current_choice_idx
        const n_choices = extension_state.choices.length;

        if (n_choices === 1) return;

        let newIndex;

        if (is_right)
            newIndex = current_idx <= n_choices - 2 ? current_idx + 1 : 0
        else
            newIndex = current_idx > 0 ? current_idx - 1 : n_choices - 1

        extension_state.current_choice_idx = newIndex;

    }

    function patchCodeCellExecuteEvent() {
        console.log(logPrefix, "Patching 'CodeCell.prototype.execute'")
        let original_codecell_execute_event = CodeCell.prototype.execute;
        CodeCell.prototype.execute = function (stop_on_error) {
            ensureEditorInsertionComplete(this);
            return original_codecell_execute_event.apply(this, arguments);
        }
    }

    const cursorAtEndOfLine = () => {
        const cell = currentCell();
        const cursor_line = cell.code_mirror.getCursor().line;
        const cursor_ch = cell.code_mirror.getCursor().ch;
        const current_line = cell.code_mirror.getLine(cursor_line);
        return current_line.length === cursor_ch;
    }

    function processTabKey(event) {
        const currentLine = getCurrentLine(currentCell());
        const is_empty_line = currentLine.trim() === "";
        const isAtEndOfLine = cursorAtEndOfLine();
        console.log(logPrefix, "In processTabKey - is_empty_line?", is_empty_line, "isAtEndOfLine?", isAtEndOfLine)

        if (extension_state.is_open && extension_state.considering_choices) {
            console.log(logPrefix, "Accepting choice with Tab")
            $('#hint-accept-link').click();
            event.preventDefault();
            return true;
        }
        // only do this if the cursor is at the end of a line
        else if (extension_state.is_open && isAtEndOfLine) {
            console.log(logPrefix, "Submitting completion query on Tab")
            scheduleQuery(0);
            event.preventDefault();
            return true;
        }
        else {
            console.log(logPrefix, "Processing ordinary Tab key")
            return false;
        }
    }

    const isCursorAtEndOfLine = (event) => {
        let cell = currentCell();
        const current_line = cell.code_mirror.getCursor().line;
        let text = cell.get_text();
        // console.log(logPrefix, "current line", current_line);
        const is_final_line = current_line === text.split('\n').length - 1;
        // console.log(logPrefix, "is final line?", is_final_line);
        if (!is_final_line) return false;

        let tsplit = text.split('\n');
        let last_line_length = tsplit[tsplit.length - 1].length

        const cursorchar = cell.code_mirror.getCursor().ch;
        const is_cursor_final = last_line_length === cursorchar;
        // console.log(logPrefix, "is cursor final", is_cursor_final);
        if (is_cursor_final) return true;

        // left and back key needs to change
        const is_left_or_back =
            event.which === keycodes.backspace ||
            event.which === keycodes.left

        if (!is_left_or_back) return false;

        const modified_is_cursor_final = last_line_length === cursorchar - 1
        // console.log(logPrefix, "is modified cursor final", modified_is_cursor_final);
        return modified_is_cursor_final
    }

    const isNonEmptyOrComment = () => {
        let cell = currentCell();
        let text = cell.get_text();
        let tsplit = text.split('\n');
        if (tsplit.length === 0)
            return false
        let last_line = tsplit[tsplit.length - 1]
        if (last_line.startsWith('#'))
            return true
        if (tsplit.length > 1 && tsplit[tsplit.length - 2].startsWith('#'))
            return true

        return last_line.trim() !== ""

    }

    const scheduleQuery = (delay = options.modify_query_delay) => {
        console.log(logPrefix, `Scheduling query to run in ${delay} ms`)
        extension_state.queryTimeout = setTimeout(sendCompletionQuery, delay);
    }


    const patchCellKeyevent = () => {
        console.log(logPrefix, "Patching 'Cell.prototype.handle_codemirror_keyevent'")
        let origHandleCodemirrorKeyEvent = CodeCell.prototype.handle_codemirror_keyevent;
        CodeCell.prototype.handle_codemirror_keyevent = function (editor, event) {
            // const is_tab = isTabKey(event);
            // const is_back = isBackKey(event);
            // console.log(logPrefix, "Handling keyevent isTabKey?", is_tab, "isBackKey?", is_back, "type?", event.type, "which keyCode?", event.which);

            const is_special_key = specials.indexOf(event.which) !== -1;
            const is_command_plus_event = isCommandPlusEvent(event);
            // const isAtEndOfLine = isCursorAtEndOfLine(event);
            const isAtEndOfLine = cursorAtEndOfLine();
            const isNonEmpty = isNonEmptyOrComment();
            const char = String.fromCharCode(event.which);
            const isTab = isTabKey(event);

            if (extension_state.is_open)
                console.log(logPrefix,
                    "Handling keyevent", event.key,
                    "type", event.type,
                    `character '${char}'`,
                    "is special?", is_special_key,
                    "isTab?", isTab,
                    "command plus event?", is_command_plus_event,
                    "isAtEndOfLine?", isAtEndOfLine,
                    "isNonEmpty?", isNonEmpty
                );

            // if the command, meta, or shift keys are pressed, just skip
            // cannot be special or command plus
            let cm_ignore;

            if (
                (this instanceof CodeCell) &&
                extension_state.is_open &&
                // !onlyModifierEvent(event) &&
                !is_special_key &&
                !is_command_plus_event
                // isAtEndOfLine &&
                // isNonEmpty
            ) {
                // if a query is scheduled, we should delete it!
                if (extension_state.queryTimeout) {
                    // console.log(logPrefix, "Deleting queryTimeout")
                    clearTimeout(extension_state.queryTimeout);
                }
                if (extension_state.current_completion_query) {
                    extension_state.current_completion_query.abort();
                    extension_state.current_completion_query = undefined;
                }

                // if (!extension_state.original_completer) {
                //     extension_state.original_completer = this.completer;
                // }

                let cell = this;

                if (cell.get_text().trim() === "") {
                    // do nothing if the cell is empty
                } else if (isTab) {
                    cm_ignore = processTabKey(event);
                    console.log(logPrefix, "Received CM ignore from Tab key", cm_ignore);
                } else if (
                    extension_state.considering_choices &&
                    extension_state.choices.length > 1 &&
                    isLeftRightKey(event)
                ) {
                    event.preventDefault();
                    cycleThroughChoices(event.which === keycodes.right);
                    insertChoice();
                } else if (extension_state.considering_choices && isLeftRightKey(event)) {
                    event.preventDefault();
                    console.log(logPrefix, "Recording left/right key")
                } else if (extension_state.considering_choices && isUpDownKey(event)) {
                    event.preventDefault();
                    console.log(logPrefix, "Recording up/down key")
                } else if (extension_state.considering_choices && isBackKey(event)) {
                    console.log(logPrefix, "Recording backspace key. Deleting suggestion.")
                    event.preventDefault()
                    $('#hint-delete-link').click();
                } else if (extension_state.considering_choices) {
                    console.log(logPrefix, "Recording ordinary key. Deleting suggestion.")
                    $('#hint-delete-link').click();
                    options.auto_submit && scheduleQuery();
                } else if (isAtEndOfLine) {
                    options.auto_submit && scheduleQuery();
                }
            }
            let ret = cm_ignore ?? origHandleCodemirrorKeyEvent.apply(this, arguments);
            // console.log(logPrefix, "Returning from patched keyevent", ret);
            return ret;
        };
    }

    const handle_jupyter_cogram_error = (jqXHR, textStatus, errorThrown) => {
        console.log('jupyter_cogram ajax error:', jqXHR, textStatus, errorThrown);
        if (textStatus === "abort") return;
        if (jqXHR?.status === 408 || jqXHR?.status === 409) {
            console.log(logPrefix, "Request timed out")
            return;
        }
        let error_obj = JSON.parse(jqXHR?.responseText ?? '');
        const error_msg = `${error_obj?.message}`
        showAlertMessage(error_msg, 10000);
    }

    const build_cogram_status_info = () => {
        let cogram_status_button = $('<button/>')
            .attr('id', 'cogram-status')
            .attr('class', 'btn btn-default')
            .attr('title', 'Cogram status')
            .attr('style', 'display: none;');

        let cogram_spinner = $('<i/>')
            .attr('id', 'cogram-spinner')
            .attr('style', 'color: green;')
            .attr('class', 'fa fa-circle-o-notch');

        cogram_status_button.append(cogram_spinner);

        $("#cogram-button-group").append(cogram_status_button);//.append(make_dropright());
    }

    const showAlertMessage = (msg, timeout = 2000) => {
        console.log(logPrefix, "Showing alert message");
        const previousContent = $("#info-panel-content").html();
        let alert_msg = $("<div class='mui--text-body2 alert-message'>" + msg + "</div>")
        showInfoPanelWithContent(alert_msg);
        timeout && setTimeout(() => {
            previousContent && $("#info-panel-content").html(previousContent);
            $("#jupyter-cogram-info-panel").hide();
        }, timeout)
    }

    const showSuccessMessage = (msg, timeout = 5000) => {
        console.log(logPrefix, "Showing success message with timeout", timeout);
        const previousContent = $("#info-panel-content").html();
        let success_msg = $("<div class='mui--text-body2 success-message'>" + msg + "</div>")
        showInfoPanelWithContent(success_msg);
        timeout && setTimeout(() => {
            previousContent && $("#info-panel-content").html(previousContent);
            $("#jupyter-cogram-info-panel").hide();
        }, timeout)
    }

    const tokenInteraction = (msg = null) => {
        let textAreaDiv = $('<div id="info-panel-content"/>')

        if (msg)
            textAreaDiv.html(msg)
        else
            textAreaDiv.text("Please submit your API token")

        let form = $('<form id="token_submit_form"><div class="mui-textfield"><input type="text"' +
            'name="api_token" placeholder="Your API token" spellcheck="false"' +
            'class="mui--is-empty mui--is-pristine mui--is-touched">' +
            '</div>' +
            '<button id="cogram_token_submit" class="mui-btn mui-btn--primary" type="submit">Submit</button></form>');
        textAreaDiv.append(form);

        // Submit button click event handler
        $('body').on('submit', '#token_submit_form', (event) => {
            event.preventDefault();
            const form = event.target;
            const [success, msg] = submitToken(form?.api_token?.value);
            if (success) {
                showSuccessMessage("Thanks, your token looks good 🎉", 2000)
            } else {
                showAlertMessage(msg, 5000);
            }
        })

        return textAreaDiv;
    }

    const getHintText = () => {
        var next = '<a href="#" class="hint-accept" id="hint-right-link">Next (→)</a>'
        var prev = '<a href="#" class="hint-accept" id="hint-left-link">Previous (←)</a>'
        var accept = '<a href="#" class="hint-accept" id="hint-accept-link">Accept (Tab)</a>'
        var del = '<a href="#" class="hint-accept" id="hint-delete-link">Delete (⌫)</a>'

        var dblsp = '&nbsp &nbsp'

        var out = ""

        if (extension_state.choices.length > 1) {
            out += `${next} ${dblsp} ${prev} ${dblsp}`
        }
        out += `${accept} ${dblsp} ${del}`

        return out;
    }

    const getCMCursorPos = () => {
        var e = $('.cell.code_cell.selected .CodeMirror-cursor')
        return [e.css("left"), e.css("top")]
    }

    const getCMcursorLineCh = (cell) => {
        const cursor = cell.code_mirror.getCursor()
        return [cursor.line, cursor.ch]
    }

    // Cursor-blinking
    function restartBlink() {
        var cm = currentCell().code_mirror;
        if (!cm.state.focused) {
            return;
        }
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0) {
            display.blinker = setInterval(function () {
                return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
            },
                cm.options.cursorBlinkRate
            );
        }
        else if (cm.options.cursorBlinkRate < 0) {
            display.cursorDiv.style.visibility = "hidden";
        }
    }

    const focusCodeMirror = () => {
        Jupyter.notebook.get_selected_cell().code_mirror.display.input.focus();
        $('.cell.code_cell.selected .CodeMirror').addClass("CodeMirror-focused")
    }

    const registerHintClicks = () => {
        $('#hint-accept-link').click(e => {
            e.preventDefault();
            acceptSuggestionWithDelay(0);
            focusCodeMirror();
            restartBlink();
        });
        $('#hint-delete-link').click(e => {
            e.preventDefault();
            stopInsertion(0)
            focusCodeMirror();
            restartBlink();
        })
        $('#hint-left-link').click(e => {
            e.preventDefault();
            cycleThroughChoices(false);
            insertChoice();
            focusCodeMirror();
            restartBlink();
        });
        $('#hint-right-link').click(e => {
            e.preventDefault();
            cycleThroughChoices(true);
            insertChoice();
            focusCodeMirror();
            restartBlink();
        });
    }

    const buildHint = (hintText) => {
        let hint = $('<div class="mui-panel" id="cogram-hint"/>')
        let hints = $(`<div class="mui--text-body2" id="cogram-hint-text">${hintText}</div>`)
        hint.append(hints);
        const cursorPos = getCMCursorPos();
        hint.css("left", cursorPos[0]).css("top", cursorPos[1]);
        hint.css("left", "+=102")
        hint.css("top", "-=14")
        $('.cell.code_cell.selected .inner_cell').append(hint);
        registerHintClicks();
    }

    const deleteHint = () => $('#cogram-hint').remove();

    const displayHint = () => {
        deleteHint();
        buildHint(getHintText())
    }

    const showInfoPanel = () => $('#jupyter-cogram-info-panel').show();

    const build_cogram_html = () => {
        let cogram_token_int = $('<div/>').attr('id', 'jupyter-cogram-info-panel')
            .attr('class', 'cogram_info_panel_display mui-panel mui--text-subhead mui--z2')
            .attr('style', 'display: none;');

        let closeButton = $("<div id='cogram_token_close'>x</div>")
        cogram_token_int.append(closeButton).append($('<div id="info-panel-content"/>'));

        // Close button click event handler
        $('body').on('click', '#cogram_token_close', () => $("#jupyter-cogram-info-panel").hide());

        // Disable jupyter shortcuts while query is being typed(to avoid them from triggering)
        $('body').on('focus', '#jupyter-cogram-info-panel', () => Jupyter.keyboard_manager.disable());
        $('body').on('blur', '#jupyter-cogram-info-panel', () => Jupyter.keyboard_manager.enable());

        $("#site").prepend(cogram_token_int);
    }

    const load_css = (fname) => {
        let link = document.createElement("link");
        link.type = "text/css";
        link.rel = "stylesheet";
        link.href = requirejs.toUrl(fname);
        document.getElementsByTagName("head")[0].appendChild(link);
    }

    const serverUnavailableMsg = "The Cogram API server is unavailable. Please refresh and try again. If this keeps happening, please contact support@cogram.ai"

    const checkValidTokenOrVersionUpdate = () => {
        const token_check_result = checkValidTokenExists();
        if (token_check_result === "ok") {
            checkIfVersionIsUpToDate()
        }
        else if (token_check_result === "unavailable") {
            showAlertMessage(serverUnavailableMsg, 10000)
        }
        else if (token_check_result) {
            showInfoPanelWithContent(tokenInteraction(token_check_result))
        }
        else {
            showInfoPanelWithContent(tokenInteraction())
        }
    }

    const refreshButton = () => {
        let refreshButton = `<button id="refresh_button" class="mui-btn mui-btn--primary">Refresh</button>`
        $('body').on('click', '#refresh_button', () => {
            window.location.reload();
        }
        );
        return refreshButton;
    }
    const autoUpgradeSuccessfulCallback = (response) => {
        extension_state.version_is_up_to_date = true;
        let msg = `<div class="mui--text-subhead">Successfully upgraded to version ${response?.new_version} 🎉` +
            `<span class="mui--text-body2"><br>Please refresh your notebook:</span></div>` +
            refreshButton()
        showSuccessMessage(msg, options.upgrade_message_timeout)
    }

    const autoUpgradeErrorCallback = (jqXHR, textStatus, errorThrown) => {
        extension_state.version_is_up_to_date = false;
        let error_obj = JSON.parse(jqXHR.responseText);
        extension_state.version_is_up_to_date = false;
        console.log(logPrefix, "Auto upgrade error:", error_obj)
        let msg = `<span class="mui--text-body2">${error_obj?.message}</span>`
        showAlertMessage(msg, 10000)
    }

    const autoUpgrade = () => {
        console.log(logPrefix, "Upgrading package");
        return $.post({
            url: '/upgrade',
            headers: { 'X-XSRFToken': _get_cookie('_xsrf') },
            dataType: "json",
            contentType: "application/json",
            success: autoUpgradeSuccessfulCallback,
            error: autoUpgradeErrorCallback
        });
    }

    const runAutoUpgrade = () => {
        autoUpgrade()
            .then(res => console.log(logPrefix, "`autoUpgrade()` result:", res))
            .catch(err => console.log(logPrefix, "Error in `autoUpgrade()`:", err))

    }

    const showLaunchInfo = () => {
        if (!extension_state.auth_token) {
            console.log(logPrefix, "No valid token. Skipping launch message.")
        }
        let status;
        let msg;
        $.get({
            url: '/launch',
            headers: { 'X-XSRFToken': _get_cookie('_xsrf') },
            async: false,
            dataType: 'JSON',
            success: (response) => {
                console.log(logPrefix, "Have launch result", response)
                status = response?.status
                msg = response?.msg
            }
            ,
            error: (jqXHR, textStatus, errorThrown) => {
                console.log(logPrefix, "Have launch result error", jqXHR)
            }
        });

        if (msg && ["first_launch", "new_version"].includes(status)) {
            console.log(logPrefix, "Will show success message.", msg);
            showSuccessMessage(msg, 60000);
        }

    }

    const launchSequence = () => {
        initialize();
        toggle_jupyter_cogram_editor(true);
        checkValidTokenOrVersionUpdate();
        showLaunchInfo();
    }

    function load_jupyter_extension() {

        load_css("//cdn.muicss.com/mui-0.10.3/css/mui.min.css");
        load_css("./jupyter_cogram.css");

        patchCellKeyevent();
        patchCodeCellExecuteEvent();
        build_cogram_html();

        if (Jupyter.notebook.kernel) {
            console.log(logPrefix, "Initialising with Kernel ready!")
            launchSequence();
        } else {
            console.log(logPrefix, "Kernel not ready. Initialising later")
            Jupyter.notebook.events.one('kernel_ready.Kernel', () => launchSequence());
        }
    }

    return {
        load_jupyter_extension: load_jupyter_extension,
        load_ipython_extension: load_jupyter_extension
    };
});
