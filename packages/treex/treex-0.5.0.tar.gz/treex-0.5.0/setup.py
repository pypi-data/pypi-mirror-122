# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['treex',
 'treex.metrics',
 'treex.metrics.classification',
 'treex.metrics.functional',
 'treex.metrics.functional.classification',
 'treex.metrics.old',
 'treex.metrics.utilities',
 'treex.nn']

package_data = \
{'': ['*']}

install_requires = \
['PyYAML>=5.4.1,<6.0.0',
 'flax>=0.3.4,<0.4.0',
 'jax==0.2.21',
 'jaxlib>=0.1.71,<0.2.0',
 'optax>=0.0.9,<0.0.10',
 'rich>=10.7.0,<11.0.0',
 'treeo>=0.0.4,<0.0.5']

setup_kwargs = {
    'name': 'treex',
    'version': '0.5.0',
    'description': '',
    'long_description': '# Treex\n\n_A Pytree Module system for Deep Learning in JAX_\n\n* **Intuitive**: Modules are simple Python objects that respect Object-Oriented semantics and should make PyTorch users feel at home, with no need for separate dictionary structures or complex `apply` methods.\n* **Pytree-based**:  Modules are registered as JAX PyTrees, enabling their use with any JAX function. No need for specialized versions of `jit`, `grad`, `vmap`, etc.\n* **Expressive**: In Treex you use type annotations to define what the different parts of your module represent (submodules, parameters, batch statistics, etc), this leads to a very flexible and powerful state management solution.\n* **Flax-based Implementations**: Writing high-quality, battle-tested code for common layers is hard. For this reason Modules in `treex.nn` are wrappers over their Flax counterparts. We keep identical signatures, enabling Flax users to feel at home but still benefiting from the simpler Pytorch-like experience Treex brings.\n\nTreex is implemented on top of [Treeo](https://github.com/cgarciae/treeo), Treex vendors all of Treeo\'s public API for ease of usage.\n\n[Documentation](https://cgarciae.github.io/treex) | [User Guide](https://cgarciae.github.io/treex/user-guide/intro)\n\n## Why Treex?\nDespite all JAX benefits, current Module systems are not intuitive to new users and add additional complexity not present in frameworks like PyTorch or Keras. Treex takes inspiration from S4TF and delivers an intuitive experience using JAX Pytree infrastructure.\n\n<details>\n<summary>Current Alternative\'s Drawbacks and Solutions</summary>\n\nCurrently we have many alternatives like Flax, Haiku, Objax, that have one or more of the following drawbacks:\n\n* Module structure and parameter structure are separate, and parameters have to be manipulated around by the end-user, which is not intuitive. In Treex, parameters are stored in the modules themselves and can be accessed directly.\n* Monadic architecture adds complexity. Flax and Haiku use an `apply` method to call modules that set a context with parameters, rng, and different metadata, which adds additional overhead to the API and creates an asymmetry in how Modules are being used inside and outside a context. In Treex, modules can be called directly.\n* Among different frameworks, parameter surgery requires special consideration and is challenging to implement. Consider a standard workflow such as transfer learning, transferring parameters and state from a  pre-trained module or submodule as part of a new module; in different frameworks, we have to know precisely how to extract their parameters and how to insert them into the new parameter structure/dictionaries such that it is in agreement with the new module structure. In Treex, just as in PyTorch / Keras, we enable to pass the (sub)module to the new module, and parameters are automatically added to the new structure.\n* Multiple frameworks deviate from JAX semantics and require particular versions of `jit`, `grad`, `vmap`, etc., which makes it harder to integrate with other JAX libraries. Treex\'s Modules are plain old JAX PyTrees and are compatible with any JAX library that supports them.\n* Other Pytree-based approaches like Parallax and Equinox do not have a total state management solution to handle complex states as encountered in Flax. Treex has the Filter and Update API, which is very expressive and can effectively handle systems with a complex state.\n\n</details>\n\n## Installation\nInstall using pip:\n```bash\npip install treex\n```\n\n## Status\nTreex is in an early stage, things might brake between versions but we will respect semanting versioning. While more testing is needed, since Treex layers are numerically equivalent to Flax this borrows some maturity and yields more confidence over its results. Feedback is much appreciated.\n\n**Roadmap**:\n\n- [x] Finish prototyping core API\n- [ ] Wrap all Flax Linen Modules\n- [x] Document public API\n- [x] Create documentation site\n\n\n## Getting Started\n<!-- Remake Getting Started now that most content is in the User Guide -->\n\nThis is a small appetizer to give you a feel for how using Treex looks like, be sure to checkout the [Guide section](#guide) below for details on more advanced usage.\n```python\nfrom typing import Sequence, List\n\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport treex as tx\n\n# you can use tx.MLP but we will create our own as an example\nclass MLP(tx.Module):\n    layers: List[tx.Linear] = tx.node()\n\n    def __init__(self, features: Sequence[int]):\n        self.layers = [\n            tx.Linear(din, dout) \n            for din, dout in zip(features[:-1], features[1:])\n        ]\n\n    def __call__(self, x):\n        for linear in self.layers[:-1]:\n            x = jax.nn.relu(linear(x))\n        return self.layers[-1](x)\n\n@jax.jit\n@jax.grad\ndef loss_fn(model, x, y):\n    y_pred = model(x)\n    return jnp.mean((y_pred - y) ** 2)\n\n# in reality use optax\ndef sdg(param, grad):\n    return param - 0.01 * grad\n\nmodel = MLP([1, 12, 8, 1]).init(42)\n\nx = np.random.uniform(-1, 1, size=(100, 1))\ny = 1.4 * x ** 2 - 0.3 + np.random.normal(scale=0.1, size=(100, 1))\n\n# training loop\nfor step in range(10_000):\n    grads = loss_fn(model, x, y)\n    model = jax.tree_map(sdg, model, grads)\n\nmodel = model.eval()\ny_pred = model(x)\n```\n\n#### Stateful Module example\nHere is an example of creating a stateful module of a `RollingMean` metric and using them with `jax.jit`:\n\n```python\nclass RollingMean(tx.Module):\n    count: jnp.ndarray = tx.State.node()\n    total: jnp.ndarray = tx.State.node()\n\n    def __init__(self):\n        self.count = jnp.array(0)\n        self.total = jnp.array(0.0)\n\n    def __call__(self, x: jnp.ndarray) -> jnp.ndarray:\n        self.count += np.prod(x.shape)\n        self.total += x.sum()\n\n        return self.total / self.count\n\n@jax.jit\ndef update(x: jnp.ndarray, metric: RollingMean) -> Tuple[jnp.ndarray, RollingMean]:\n    mean = metric(x)\n    return mean, metric # return mean value and updated metric\n\n\nmetric = RollingMean()\n\nfor i in range(10):\n    x = np.random.uniform(-1, 1, size=(100, 1))\n    mean, metric = update(x, metric)\n\nprint(mean)\n```\n\n#### Linear Regression from scratch example\n\n```python\nfrom functools import partial\nfrom typing import Union\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport optax\nimport treex as tx\n\nx = np.random.uniform(size=(500, 1))\ny = 1.4 * x - 0.3 + np.random.normal(scale=0.1, size=(500, 1))\n\n\nclass Linear(tx.Module):\n    w: Union[tx.Initializer, jnp.ndarray] = tx.Parameter.node()\n    b: jnp.ndarray = tx.Parameter.node()\n\n    def __init__(self, din, dout):\n\n        self.w = tx.Initializer(lambda key: jax.random.uniform(key, shape=(din, dout)))\n        self.b = jnp.zeros(shape=(dout,))\n\n    def __call__(self, x):\n        return jnp.dot(x, self.w) + self.b\n\n\n@partial(jax.value_and_grad, has_aux=True)\ndef loss_fn(params, model, x, y):\n    model = model.merge(params)\n\n    y_pred = model(x)\n    loss = jnp.mean((y_pred - y) ** 2)\n\n    return loss, model\n\n\n@jax.jit\ndef train_step(model, x, y, optimizer):\n    params = model.filter(tx.Parameter)\n    (loss, model), grads = loss_fn(params, model, x, y)\n\n    # here model == params\n    model = optimizer.update(grads, model)\n\n    return loss, model, optimizer\n\n\nmodel = Linear(1, 1).init(42)\noptimizer = tx.Optimizer(optax.adam(0.01))\noptimizer = optimizer.init(model)\n\nfor step in range(1000):\n    loss, model, optimizer = train_step(model, x, y, optimizer)\n    if step % 100 == 0:\n        print(f"loss: {loss:.4f}")\n\nmodel = model.eval()\n\nX_test = np.linspace(x.min(), x.max(), 100)[:, None]\ny_pred = model(X_test)\n\nplt.scatter(x, y, c="k", label="data")\nplt.plot(X_test, y_pred, c="b", linewidth=2, label="prediction")\nplt.legend()\nplt.show()\n\n```\n',
    'author': 'Cristian Garcia',
    'author_email': 'cgarcia.e88@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://cgarciae.github.io/treex',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
