import pandas as pd
import numpy as np
import json
import time
import copy

from aegis.panconfiguration import pan
from aegis.modules.popgenstats import PopgenStats


class Recorder:
    """Data recorder

    Records data generated by the simulation.

    When thinking about recording additional data, consider that there are three recording methods:
        I. Snapshots (record data from the population at a specific stage)
        II. Flushes (collect data over time then flush)
        III. One-time records
    """

    def __init__(self, ecosystem_id, MAX_LIFESPAN):
        # Define output paths and make necessary directories
        opath = pan.output_path / str(ecosystem_id)
        self.paths = {
            "BASE_DIR": opath,
            "snapshots_genotypes": opath / "snapshots" / "genotypes",
            "snapshots_phenotypes": opath / "snapshots" / "phenotypes",
            "snapshots_demography": opath / "snapshots" / "demography",
            "visor": opath / "visor",
            "visor_spectra": opath / "visor" / "spectra",
            "output_summary": opath,
        }
        for path in self.paths.values():
            path.mkdir(exist_ok=True, parents=True)

        # Initialize collection
        self._collection = {
            "age_at_birth": [0] * MAX_LIFESPAN,
            "age_at_overshoot": [0] * MAX_LIFESPAN,
            "age_at_genetic": [0] * MAX_LIFESPAN,
            "age_at_season_shift": [0] * MAX_LIFESPAN,
            "cumulative_ages": [0] * MAX_LIFESPAN,
            "age_at_end_of_sim": [0] * MAX_LIFESPAN,
        }
        self.collection = copy.deepcopy(self._collection)

        # Needed for output summary
        self.extinct = False

        # PopgenStats
        self.popgenstats = PopgenStats()

    # ===============================
    # RECORDING METHOD I. (snapshots)
    # ===============================

    def record_visor(self, population):
        """Record data that is needed by visor."""
        if pan.skip(pan.VISOR_RATE_):
            return

        # genotypes.csv | Record allele frequency
        with open(self.paths["visor"] / "genotypes.csv", "ab") as f:
            array = population.genomes.reshape(len(population), -1).mean(0)
            np.savetxt(f, [array], delimiter=",", fmt="%1.3e")

        # phenotypes.csv | Record median phenotype
        with open(self.paths["visor"] / "phenotypes.csv", "ab") as f:
            array = np.median(population.phenotypes, 0)
            np.savetxt(f, [array], delimiter=",", fmt="%1.3e")

        self.flush()

    def record_snapshots(self, population):
        """Record demographic, genetic and phenotypic data from the current population."""
        if pan.skip(pan.SNAPSHOT_RATE_):
            return

        # genotypes
        df_gen = pd.DataFrame(np.array(population.genomes.reshape(len(population), -1)))
        df_gen.reset_index(drop=True, inplace=True)
        df_gen.columns = [str(c) for c in df_gen.columns]
        df_gen.to_feather(self.paths["snapshots_genotypes"] / f"{pan.stage}.feather")

        # phenotypes
        df_phe = pd.DataFrame(np.array(population.phenotypes))
        df_phe.reset_index(drop=True, inplace=True)
        df_phe.columns = [str(c) for c in df_phe.columns]
        df_phe.to_feather(self.paths["snapshots_phenotypes"] / f"{pan.stage}.feather")

        # demography
        dem_attrs = ["ages", "births", "birthdays"]
        demo = {attr: getattr(population, attr) for attr in dem_attrs}
        df_dem = pd.DataFrame(demo, columns=dem_attrs)
        df_dem.reset_index(drop=True, inplace=True)
        df_dem.to_feather(self.paths["snapshots_demography"] / f"{pan.stage}.feather")

    def record_popgenstats(self, population):
        if pan.skip(pan.POPGENSTATS_RATE_):
            return

        with open(self.paths["BASE_DIR"] / "popgenstats.csv", "ab") as f:
            array = self.popgenstats.analyze(population)
            np.savetxt(f, [array], delimiter=",", fmt="%1.3e")

    # ==============================
    # RECORDING METHOD II. (flushes)
    # ==============================

    def collect(self, key, ages):
        """Add data into memory which will be recorded later."""
        for age in ages:
            self.collection[key][age] += 1

    def flush(self):
        """Record data that has been collected over time."""
        # spectra/*.csv | Age distribution of various subpopulations (e.g. population that died of genetic causes)
        for key, val in self.collection.items():
            with open(self.paths["visor_spectra"] / f"{key}.csv", "ab") as f:
                array = np.array(val)
                np.savetxt(f, [array], delimiter=",", fmt="%i")

        # Reinitialize the collection
        self.collection = copy.deepcopy(self._collection)

    # =================================
    # RECORDING METHOD III. (record once)
    # =================================

    def record_output_summary(self):
        output_summary = {
            "extinct": self.extinct,
            "random_seed": pan.random_seed,
            "time_start": pan.time_start,
            "time_end": time.time(),
        }
        with open(self.paths["output_summary"] / "output_summary.json", "w") as f:
            json.dump(output_summary, f, indent=4)
