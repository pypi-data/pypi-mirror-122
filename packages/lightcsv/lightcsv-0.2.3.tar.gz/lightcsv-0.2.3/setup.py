# -*- coding: utf-8 -*-
from setuptools import setup

modules = \
['lightcsv']
setup_kwargs = {
    'name': 'lightcsv',
    'version': '0.2.3',
    'description': 'Simple pure Python CSV parser',
    'long_description': '# LightCSV\n\n[![Python 3.8](https://img.shields.io/badge/python-3.8-blue.svg)](https://www.python.org/downloads/release/python-380/)\n[![Python 3.8](https://img.shields.io/badge/python-3.9-greensvg)](https://www.python.org/downloads/release/python-390/)\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\nSimple light CSV reader\n\nThis CSV reader is implemented in just pure Python. It allows to specify a separator, a quote char and\ncolumn titles (or get the first row as titles). Nothing more, nothing else.\n\n## Usage\n\nUsage is pretty straightforward:\n\n```python\nfrom lightcsv import LightCSV\n\nfor row in LightCSV().read_file("myfile.csv"):\n    print(row)\n```\n\nThis will open a file named `myfile.csv` and iterate over the CSV file returning each \nrow as a key-value dictionary. Line endings can be either `\\n` or `\\r\\n`. The file will be opened\nin text-mode with `utf-8` encoding.\n\nYou can supply your own stream (i.e. an open file instead of a filename). You can use this, for example,\nto open a file with a different encoding, etc.:\n\n```python\nfrom lightcsv import LightCSV\n\nwith open("myfile.csv") as f:\n    for row in LightCSV().read(f):\n        print(row)\n```\n\n    NOTE: Blank lines at any point in the file will be ignored\n\n### Parameters\n\nLightCSV can be parametrized during initialization to fine-tune its behaviour.\n\nThe following example shows initialization with default parameters:\n\n```python\nfrom lightcsv import LightCSV\n\nmyCSV_reader = LightCSV(\n    separator=",",\n    quote_char=\'"\',\n    field_names = None,\n    strict=True,\n    has_headers=False\n)\n```\n\nAvailable settings:\n\n * `separator`: character used as separator (defaults to `,`)\n * `quote_char`: character used to quote strings (defaults to `"`).<br />\n    This char can be escaped by duplicating it.\n * `field_names`: can be any iterable or sequence of `str` (i.e. a list of strings).<br />\n    If set, these will be used as column titles (dictionary keys), and also sets the expected number of columns.</br>\n * `strict`: Sets whether the parser runs in _strict mode_ or not.<br />\n    In _strict mode_ the parser will raise a `ValueError` exception if a cell cannot be decoded or column\n    numbers don\'t match. In _non-strict mode_ non-recognized cells will be returned as strings. If there are more\n    columns than expected they will be ignored. If there are less, the dictionary will contain also fewer values.\n * `has_headers`: whether the first row should be taken as column titles or not.<br />\n    If set, `field_names` cannot be specified. If not set, and no field names are specified, dictionary keys will\n    be just the column positions of the cells.\n\n \n## Data types recognized\n\nThe parser will try to match the following types are recognized in this order:\n\n * `None` (empty values). Unlike CSV reader, it will return `None` (null) for empty values. <br />\n    Empty strings (`""`) are recognized correctly.\n * `str` (strings): Anything that is quoted with the `quotechar`. Default quotechar is `"`. <br />\n    If the string contains a quote, it must be escaped duplicating it. i.e. `"HELLO ""WORLD"""` decodes\n    to `HELLO "WORLD"` string.\n * `int` (integers): an integer with a preceding optional sign.\n * `float`: any float recognized by Python\n * `datetime`: a datetime in ISO format (with \'T\' or whitespace in the middle), like `2022-02-02 22:02:02`\n * `date`: a date in ISO format, like `2022-02-02`\n * `time`: a time in ISO format, like `22:02:02`\n \n\nIf all this parsing attempts fails, a string will be returned, unless `strict_mode` is set to `True`. In the latter\ncase, a `ValueError` exception will be raised.\n\n\n## Implementing your own type recognizer\n\nYou can implement your own deserialization by subclassing `LightCSV` and override the method `parse_obj()`.\n\nFor example, suppose we want to recognize hexadecimal integers in the format `0xNNN...`. We can implement it\nthis way:\n\n```python\nimport re\nfrom lightcsv import LightCSV\n\nRE_HEXA = re.compile(\'0[xX][A-Za-z0-9]+$\')  # matches 0xNNNN (hexadecimals)\n\n\nclass CSVHexRecognizer(LightCSV):\n    def parse_obj(self, lineno: int, chunk: str):\n        if RE_HEXA.match(chunk):\n            return int(chunk[2:], 16)\n        \n        return super().parse_obj(lineno, chunk)\n```\n\nAs you can see, you have to override `parse_obj()`. If your match fails, you have to invoke `super()` (overridden) \n`parse_obj()` method and return its result.\n\n\n---\n\n## Why\n\nPython built-in CSV module is a bit over-engineered for simple tasks, and one normally doesn\'t need all bells\nand whistles. With `LightCSV` you just open a filename and iterate over its rows.\n\nDecoding `None` for empty cells is needed very often and can be really cumbersome as the standard `csv`\ntries hard to cover many corner-cases (if that\'s your case, this tool might not be suitable for you).\n',
    'author': 'Jose Rodriguez',
    'author_email': 'boriel@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/boriel/lightcsv',
    'py_modules': modules,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
