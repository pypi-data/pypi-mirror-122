"""Transform a python function into a corresponding pydantic model.

The :class:`BackendFunction` model in this module generates subclasses based
upon a python class (similarly as the
:class:`~demessaging.backend.class_.BackendClass` does it for classes).
"""
from __future__ import annotations
from functools import partial
from typing import (
    Any,
    Callable,
    Type,
    Dict,
    cast,
    Optional,
    ClassVar,
    TYPE_CHECKING,
)
import warnings


from textwrap import dedent

import inspect


import docstring_parser

from pydantic import (  # pylint: disable=no-name-in-module
    BaseModel,
    Field,
    create_model,
)
from pydantic.json import (  # pylint: disable=no-name-in-module
    custom_pydantic_encoder,
)


from demessaging.config import FunctionConfig
import demessaging.backend.utils as utils


def get_return_field(
    docstring: docstring_parser.Docstring, config: FunctionConfig
) -> Any:
    """Generate field for the return property

    Our function models get a ``func_returns`` property to highlight the return
    type for the user.

    Parameters
    ----------
    docstring : docstring_parser.Docstring
        The parser that analyzed the docstring

    Returns
    -------
    Any
        The pydantic field
    """
    return_description = ""
    ret_count: int = 0
    for arg in docstring.meta:
        if (
            isinstance(arg, docstring_parser.DocstringReturns)
            and arg.description
        ):
            return_description += "\n- " + arg.description
            ret_count += 1
    return_description = return_description.strip()
    if ret_count == 1:
        return_description = return_description[2:]

    field_kws: Dict[str, Any] = {"default": None}

    if return_description.strip():
        field_kws["description"] = return_description

    field_kws.update(config.returns)

    return Field(**field_kws)


class BackendFunctionConfig(FunctionConfig):
    """Configuration class for a backend module function."""

    function: Any = Field(description="The function to call.")

    class_name: str = Field(description="Name of the model class")

    def update_from_function(self) -> None:
        """Update the config from the corresponding function."""
        func = self.function
        if not self.name:
            self.name = func.__name__ or ""
        if not self.doc:
            self.doc = dedent(inspect.getdoc(func) or "")
        if not self.signature:
            self.signature = inspect.signature(func)


class BackendFunction(BaseModel):
    """A base class for a function model.

    Don't use this model, rather use :meth:`create_model` method to
    generate new models.
    """

    class Config:
        validate_assignment = True

    backend_config: ClassVar[BackendFunctionConfig]

    if TYPE_CHECKING:
        # added properties for subclasses generated by create_model
        func_name: str
        func_returns: Any

    def __call__(self) -> BackendFunction:  # type: ignore
        kws = self.dict()

        kws.pop("func_name")
        kws.pop("func_returns", None)
        ret = self.backend_config.function(**kws)

        self.func_returns = ret
        return self

    @classmethod
    def create_model(
        cls,
        func: Callable,
        config: Optional[FunctionConfig] = None,
        class_name=None,
        **kwargs,
    ) -> Type[BackendFunction]:
        """Create a new pydantic Model from a function.

        Parameters
        ----------
        func: callable
            A function or method
        config: FunctionConfig, optional
            The configuration to use. If given, this overrides the
            ``__pulsar_config__`` of the given `func`
        class_name: str, optional
            The name for the generated subclass of :class:`pydantic.BaseModel`.
            If not given, the name of `func` is used
        ``**kwargs``
            Any other parameter for the :func:`pydantic.create_model` function

        Returns
        -------
        Subclass of BackendFunction
            The newly generated class that represents this function.
        """
        sig = inspect.signature(func)
        docstring = docstring_parser.parse(func.__doc__)

        if config is None:
            config = getattr(func, "__pulsar_config__", FunctionConfig())

        name = cast(str, func.__name__)
        if not class_name:
            class_name = utils.snake_to_camel("Func", name)

        config = BackendFunctionConfig(
            function=func,
            class_name=class_name,
            **config.copy(deep=True).dict(),
        )

        fields = utils.get_fields(name, sig, docstring, config)

        desc = utils.get_desc(docstring)

        ret_field = get_return_field(docstring, config)

        if sig.return_annotation is not sig.empty:
            fields["func_returns"] = sig.return_annotation, ret_field
        else:
            warnings.warn(
                f"Missing return signature for {func.__name__}!",
                RuntimeWarning,
            )
            fields["func_returns"] = Any, ret_field

        kwargs.update(fields)

        Model: Type[BackendFunction] = create_model(  # type: ignore
            class_name,
            __validators__=config.validators,
            __base__=cls,
            __module__=func.__module__,
            **kwargs,  # type: ignore
        )

        Model.backend_config = config

        if config.registry.json_encoders:
            # it would be better, to set this via __config__ in create_model,
            # but this is not possible if we use `__base__`
            Model.__config__.json_encoders = config.registry.json_encoders
            Model.__json_encoder__ = partial(
                custom_pydantic_encoder, config.registry.json_encoders
            )

        config.function = func

        config.update_from_function()

        if desc:
            Model.__doc__ = desc
        else:
            Model.__doc__ = ""

        return Model


BackendFunctionConfig.update_forward_refs()
