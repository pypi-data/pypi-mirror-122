{"version":3,"sources":["services/api/runs/runsService.ts","utils/encoder/streamEncoding.ts","services/models/runs/runsAppModel.ts","pages/Runs/Runs.tsx","pages/Runs/RunsContainer.tsx"],"names":["endpoints","GET_RUNS","GET_RUN_INFO","id","GET_RUN_BATCH_BY_TRACES","ARCHIVE_RUN","runsService","getRunsData","query","API","getStream","q","getRunInfo","get","getRunBatch","body","post","headers","archiveRun","archived","put","AimObjectFlag","flagType","this","ArrayFlag","ObjectFlag","utf8decoder","TextDecoder","decodeInt","buffer","len","byteLength","decode_q_le","Uint8Array","struct","size","unpack","decodeString","decode","decodeByType","typeId","value","decodeBool","decodeFloat","decodeValue","array","bufferValue","slice","arrayBuffer","byteOffset","Math","pow","decode_q_be","decodePath","key","path","length","cursor","keySize","index","indexOf","push","valToNode","val","TypeError","iterFoldTree","pathsVals","a","level","stack","next","item","done","undefined","keys","node","isEqual","lastState","pop","Error","keyToAdd","Array","isArray","adjustable_reader","stream","ArrayBuffer","reader","getReader","p","read","chunk","to_buffer","subarray","set","RangeError","decode_buffer_pairs","async_generator","key_buffer_len","key_buffer","val_buffer_len","value_buffer","decodePathsVals","currentPath","encodedPath","encodedVal","model","createModel","runAppModel","initialize","init","call","abort","gen","buffer_pairs","decodedPairs","objects","runsData","runData","hash","setState","data","Runs","Box","bgcolor","component","height","overflow","className","Grid","container","direction","justifyContent","spacing","map","run","to","runsRequestRef","runsAppModel","RunsContainer","useModel","React","useEffect","memo"],"mappings":"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","file":"static/js/17.b10132a2.chunk.js","sourcesContent":["import API from '../api';\n\nconst endpoints = {\n  GET_RUNS: 'runs/search/run',\n  GET_RUN_INFO: (id: string) => `runs/${id}/info`,\n  GET_RUN_BATCH_BY_TRACES: (id: string) => `runs/${id}/traces/get-batch`,\n  ARCHIVE_RUN: (id: string) => `runs/${id}`,\n};\n\nfunction getRunsData(query?: string) {\n  return API.getStream<ReadableStream>(endpoints.GET_RUNS, {\n    q: query || 'True',\n  });\n}\n\nfunction getRunInfo(id: string) {\n  return API.get(endpoints.GET_RUN_INFO(id));\n}\n\nfunction getRunBatch(body: any, id: string) {\n  return API.post(endpoints.GET_RUN_BATCH_BY_TRACES(id), body, {\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n}\n\nfunction archiveRun(id: string, archived: boolean = false) {\n  return API.put(\n    endpoints.ARCHIVE_RUN(id),\n    { archived },\n    {\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    },\n  );\n}\n\nconst runsService = {\n  endpoints,\n  getRunsData,\n  getRunInfo,\n  getRunBatch,\n  archiveRun,\n};\n\nexport default runsService;\n","// @ts-nocheck\n\nimport { isEqual } from 'lodash-es';\nimport struct from '@aksel/structjs';\n\nconst PATH_SENTINEL = 0xfe;\n// const SIZE_T = 'q';\n\nconst NONE = 0;\nconst BOOL = 1;\nconst INT = 2; // Stored as 64-bit Long Long\nconst FLOAT = 3; // Stored as 64-bit Double\nconst STRING = 4;\nconst BYTES = 5;\nconst ARRAY = 6;\nconst OBJECT = 7;\n\nclass AimObjectFlag {\n  private flagType: string;\n  constructor(flagType: string) {\n    this.flagType = flagType;\n  }\n\n  toString() {\n    return `<${this.flagType}>`;\n  }\n}\nconst ArrayFlag = new AimObjectFlag('ARRAY_FLAG');\nconst ObjectFlag = new AimObjectFlag('OBJECT_FLAG');\n\nlet utf8decoder = new TextDecoder('utf-8');\n\nfunction decodeNone(buffer: ArrayBuffer) {\n  return null;\n}\n\nfunction decodeBool(buffer: ArrayBuffer) {\n  return struct('<?').unpack(buffer)[0];\n}\n\nfunction decodeInt(buffer: ArrayBuffer) {\n  const len = buffer.byteLength;\n  if (len === 8) {\n    return decode_q_le(...new Uint8Array(buffer));\n  } else if (len === struct('<l').size) {\n    return struct('<l').unpack(buffer)[0];\n  } else if (len === struct('<h').size) {\n    return struct('<h').unpack(buffer)[0];\n  }\n}\n\nfunction decodeFloat(buffer: ArrayBuffer) {\n  const len = buffer.byteLength;\n  if (len === struct('<d').size) {\n    return struct('<d').unpack(buffer)[0];\n  } else if (len === struct('<f').size) {\n    return struct('<f').unpack(buffer)[0];\n  } else if (len === struct('<e').size) {\n    return struct('<e').unpack(buffer)[0];\n  }\n}\n\nfunction decodeString(buffer: ArrayBuffer) {\n  return utf8decoder.decode(buffer);\n}\n\nfunction decodeBytes(buffer: ArrayBuffer) {\n  return buffer;\n}\n\nfunction decodeByType(typeId: number, buffer: ArrayBuffer) {\n  let value;\n  switch (typeId) {\n    case NONE:\n      value = decodeNone(buffer);\n      break;\n    case BOOL:\n      value = decodeBool(buffer);\n      break;\n    case INT:\n      value = decodeInt(buffer);\n      break;\n    case FLOAT:\n      value = decodeFloat(buffer);\n      break;\n    case STRING:\n      value = decodeString(buffer);\n      break;\n    case BYTES:\n      value = decodeBytes(buffer);\n      break;\n    case ARRAY:\n      value = ArrayFlag;\n      break;\n    case OBJECT:\n      value = ObjectFlag;\n      break;\n  }\n\n  return value;\n}\n\nfunction typedArrayToBuffer(array: Uint8Array): ArrayBuffer {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteLength + array.byteOffset,\n  );\n}\n\nfunction decodeValue(buffer: Uint8Array): any {\n  const bufferValue = buffer.slice(1);\n  const arrayBuffer = typedArrayToBuffer(bufferValue);\n  const typeId = buffer[0];\n\n  return decodeByType(typeId as number, arrayBuffer);\n}\n\nfunction decode_q_le(...x: number[]) {\n  return (\n    x[7] * Math.pow(2, 56) +\n    x[6] * Math.pow(2, 48) +\n    x[5] * Math.pow(2, 40) +\n    x[4] * Math.pow(2, 32) +\n    x[3] * (1 << 24) +\n    x[2] * (1 << 16) +\n    x[1] * (1 << 8) +\n    x[0] * (1 << 0)\n  );\n}\n\nfunction decode_q_be(...x: number[]) {\n  return (\n    x[0] * Math.pow(2, 56) +\n    x[1] * Math.pow(2, 48) +\n    x[2] * Math.pow(2, 40) +\n    x[3] * Math.pow(2, 32) +\n    x[4] * (1 << 24) +\n    x[5] * (1 << 16) +\n    x[6] * (1 << 8) +\n    x[7] * (1 << 0)\n  );\n}\n\nfunction decodePath(buffer: Uint8Array): (string | number)[] {\n  const path = [];\n  let key: string | number;\n\n  let len = buffer.length;\n\n  for (let cursor = 0; cursor < len; cursor++) {\n    if (buffer[cursor] === PATH_SENTINEL) {\n      let keySize = 8; // struct.sizeFor(SIZE_T);\n      key = decode_q_be(...buffer.slice(cursor + 1, cursor + keySize + 1));\n      cursor += keySize + 1;\n    } else {\n      const index = buffer.indexOf(PATH_SENTINEL, cursor);\n      let keyBuffer = buffer.buffer.slice(\n        buffer.byteOffset + cursor,\n        buffer.byteOffset + index,\n      );\n      key = decodeString(keyBuffer);\n      cursor = index;\n    }\n    path.push(key);\n  }\n\n  return path;\n}\n\ntype AimObjectPrimitive = null | boolean | number | string | ArrayBuffer;\ntype AimObjectArray = AimObject[];\ntype AimObjectDict = { [key: string]: AimObject };\ntype AimObjectNode = AimObjectDict | AimObjectArray;\n\ntype AimObject = AimObjectPrimitive | AimObjectNode;\n\ntype AimObjectKey = string | number;\ntype AimObjectPath = AimObjectKey[];\n\nfunction valToNode(val: AimObjectPrimitive | AimObjectFlag): AimObject {\n  if (val instanceof AimObjectFlag) {\n    if (val === ObjectFlag) {\n      return {};\n    }\n    if (val === ArrayFlag) {\n      return [];\n    }\n\n    throw new TypeError('Not implemented flag');\n  }\n\n  return val;\n}\n\nexport async function* iterFoldTree(\n  pathsVals: AsyncGenerator<\n    [AimObjectPath, AimObjectPrimitive | AimObjectFlag]\n  >,\n  level: number = 0,\n): AsyncGenerator<[AimObjectPath, AimObject | undefined]> {\n  const stack: AimObject[] = [];\n  const path: AimObjectPath = [];\n\n  let item: IteratorResult<\n    [AimObjectPath, AimObjectPrimitive | AimObjectFlag],\n    void\n  >;\n\n  item = await pathsVals.next();\n  if (item.done) {\n    if (level > 0) {\n      return;\n    }\n\n    yield [[], undefined];\n    return;\n  }\n\n  let [keys, val] = item.value;\n\n  if (keys.length) {\n    return;\n  }\n\n  let node = valToNode(val);\n  stack.push(node);\n\n  for await (let [keys, val] of pathsVals) {\n    while (!isEqual(path, keys.slice(0, path.length))) {\n      let lastState = stack.pop();\n      if (stack.length === level) {\n        yield [path.slice(), lastState];\n      }\n      path.pop();\n    }\n\n    node = valToNode(val);\n\n    if (keys.length !== path.length + 1) {\n      throw new Error('Assertion Error');\n    }\n    let keyToAdd: AimObjectKey = keys[keys.length - 1];\n    path.push(keyToAdd);\n\n    if (stack.length === 0) {\n      throw new Error('Assertion Error');\n    }\n\n    let lastState = stack[stack.length - 1] as AimObjectNode;\n\n    if (Array.isArray(lastState)) {\n      while (lastState.length !== (keyToAdd as number)) {\n        lastState.push(null);\n      }\n      lastState.push(node);\n    } else {\n      lastState[keyToAdd] = node;\n    }\n\n    stack.push(node);\n  }\n\n  if (level < stack.length) {\n    yield [path.slice(0, level), stack[level]];\n  }\n}\n\nexport async function* adjustable_reader(\n  stream: ReadableStream,\n): AsyncGenerator<Uint8Array, void, number> {\n  // @ts-ignore\n  let buffer = new Uint8Array(new ArrayBuffer(yield));\n  let cursor = 0;\n  let reader = stream.getReader();\n  let done = false;\n  let p = reader.read();\n  while (true) {\n    let item = await p;\n    p = reader.read();\n    done = item.done;\n    if (done) {\n      break;\n    }\n    let chunk = item.value;\n    while (chunk.byteLength > 0) {\n      if (cursor + chunk.byteLength >= buffer.byteLength) {\n        let to_buffer = chunk.subarray(0, buffer.byteLength - cursor);\n        buffer.set(to_buffer, cursor);\n        chunk = chunk.subarray(buffer.byteLength - cursor);\n        buffer = new Uint8Array(new ArrayBuffer(yield buffer));\n        cursor = 0;\n      } else {\n        buffer.set(chunk, cursor);\n        cursor += chunk.byteLength;\n        break;\n      }\n    }\n  }\n  if (cursor !== 0) {\n    throw new RangeError('Can not read given number of bytes. EOF');\n  }\n}\n\nexport async function* decode_buffer_pairs(\n  async_generator: AsyncGenerator<Uint8Array, void, number>,\n): AsyncGenerator<[Uint8Array, Uint8Array]> {\n  let item: IteratorResult<Uint8Array, void>;\n  await async_generator.next();\n  while (true) {\n    item = await async_generator.next(4);\n    if (item.done) {\n      break;\n    }\n\n    let key_buffer_len =\n      (item.value[0] << 0) +\n      (item.value[1] << 8) +\n      (item.value[2] << 16) +\n      (item.value[3] << 24);\n    item = await async_generator.next(key_buffer_len);\n    if (item.done) {\n      throw new Error('Corrupted stream');\n    }\n\n    let key_buffer = item.value;\n\n    item = await async_generator.next(4);\n    if (item.done) {\n      throw new Error('Corrupted stream');\n    }\n\n    let val_buffer_len =\n      (item.value[0] << 0) +\n      (item.value[1] << 8) +\n      (item.value[2] << 16) +\n      (item.value[3] << 24);\n\n    item = await async_generator.next(val_buffer_len);\n    if (item.done) {\n      throw new Error('Corrupted stream');\n    }\n\n    let value_buffer = item.value;\n\n    yield [key_buffer, value_buffer];\n  }\n}\n\nexport async function* decodePathsVals(\n  pathsVals: AsyncGenerator<[Uint8Array, Uint8Array]>,\n): AsyncGenerator<[AimObjectPath, AimObjectPrimitive | AimObjectFlag]> {\n  let currentPath: AimObjectPath | null = null;\n\n  for await (let [encodedPath, encodedVal] of pathsVals) {\n    let path: AimObjectPath = decodePath(encodedPath);\n    let val: AimObjectPrimitive = decodeValue(encodedVal);\n\n    if (currentPath === null) {\n      if (path.length) {\n        yield [[], ObjectFlag];\n      }\n      currentPath = [];\n    }\n\n    while (!isEqual(path.slice(0, currentPath.length), currentPath)) {\n      currentPath.pop();\n    }\n\n    while (!isEqual(currentPath, path)) {\n      currentPath.push(path[currentPath.length]);\n      if (!isEqual(currentPath, path)) {\n        yield [currentPath, ObjectFlag];\n      }\n    }\n\n    yield [path, val];\n  }\n}\n","import runsService from 'services/api/runs/runsService';\nimport createModel from '../model';\nimport {\n  adjustable_reader,\n  decodePathsVals,\n  decode_buffer_pairs,\n  iterFoldTree,\n} from 'utils/encoder/streamEncoding';\nimport {\n  IMetricTrace,\n  IParamTrace,\n  IRun,\n} from 'types/services/models/metrics/runModel';\n\nconst model = createModel<Partial<any>>({});\n\nfunction initialize() {\n  model.init();\n}\n\nfunction getRunsData() {\n  const { call, abort } = runsService.getRunsData();\n  return {\n    call: async () => {\n      const stream = await call();\n      let gen = adjustable_reader(stream);\n      let buffer_pairs = decode_buffer_pairs(gen);\n      let decodedPairs = decodePathsVals(buffer_pairs);\n      let objects = iterFoldTree(decodedPairs, 1);\n\n      const runsData: IRun<IMetricTrace | IParamTrace>[] = [];\n      for await (let [keys, val] of objects) {\n        const runData: any = val;\n        runsData.push({ ...runData, hash: keys[0] } as any);\n      }\n\n      model.setState({\n        data: runsData,\n      });\n    },\n    abort,\n  };\n}\n\nconst runAppModel = {\n  ...model,\n  initialize,\n  getRunsData,\n};\n\nexport default runAppModel;\n","import React from 'react';\nimport { NavLink } from 'react-router-dom';\nimport { Box, Grid } from '@material-ui/core';\nimport {\n  IMetricTrace,\n  IParamTrace,\n  IRun,\n} from 'types/services/models/metrics/runModel';\nimport { IRunsProps } from 'types/pages/runs/Runs';\n\nfunction Runs({\n  runsData,\n}: IRunsProps): React.FunctionComponentElement<React.ReactNode> {\n  return (\n    <Box\n      bgcolor='grey.200'\n      component='section'\n      height='100vh'\n      overflow='hidden'\n      className='Params'\n    >\n      <Grid\n        container\n        direction='column'\n        justifyContent='center'\n        className='Params__fullHeight'\n        spacing={1}\n      >\n        <Grid item>\n          {runsData?.map((run: IRun<IMetricTrace | IParamTrace>) => (\n            <NavLink key={run.hash} to={`runs/${run.hash}`}>\n              <p>{run.hash}</p>\n            </NavLink>\n          ))}\n        </Grid>\n      </Grid>\n    </Box>\n  );\n}\n\nexport default Runs;\n","import React, { memo } from 'react';\nimport runsAppModel from 'services/models/runs/runsAppModel';\nimport useModel from 'hooks/model/useModel';\nimport Runs from './Runs';\n\nconst runsRequestRef = runsAppModel.getRunsData();\nfunction RunsContainer(): React.FunctionComponentElement<React.ReactNode> {\n  const runsData = useModel(runsAppModel);\n\n  React.useEffect(() => {\n    runsAppModel.initialize();\n    runsRequestRef.call();\n    return () => {\n      runsRequestRef.abort();\n    };\n  }, []);\n  return <Runs runsData={runsData?.data} />;\n}\n\nexport default memo(RunsContainer);\n"],"sourceRoot":""}