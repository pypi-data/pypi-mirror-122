{"version":3,"file":"lib_index_js.a6a81370bd31f0d9.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAoD;AACH;AAEZ;AACmB;AACxD,WAAW,mBAAmB;AAC9B,WAAW,UAAU;AACkB;AACvC;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,mCAAmC;AACrG,qEAAqE,wCAAwC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAI,GAAG,6BAA6B;AACpE;AACA,8BAA8B,oCAAoC;AAClE,8BAA8B,2CAA2C;AACzE,8BAA8B,mBAAmB;AACjD,8BAA8B,0CAA0C;AACxE,8BAA8B,0CAA0C;AACxE,8BAA8B,uCAAuC;AACrE,8BAA8B,uCAAuC;AACrE,8BAA8B,mBAAmB;AACjD,2BAA2B,iDAAI,GAAG,6BAA6B;AAC/D,8BAA8B,wCAAwC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA,6BAA6B;AAC7B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAS;AAC/C,4BAA4B,4DAA4D;AACxF,iBAAiB;AACjB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAwD;AAC3F;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qEAAmB,GAAG,iCAAiC;AAC/D;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,iBAAiB,+BAA+B,qEAAqE;;AAEhI;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,sDAAsD,0CAA0C;AAChG;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,sCAAsC;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;;AAEP;AACA;AACA;;;;AAIA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB,EAAE,2DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://jupyterlab_cell_autorun_kernel_restart/./lib/index.js"],"sourcesContent":["import { InputDialog, } from '@jupyterlab/apputils';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { // CodeCell, \nCellModel } from '@jupyterlab/cells';\nimport { INotebookTracker } from '@jupyterlab/notebook';\n//import { ConnectionStatus } from '@jupyterlab/services/lib/kernel/kernel';\n//import { LabIcon } from '@jupyterlab/ui-components'\nimport { Menu } from '@lumino/widgets';\n//import reinit from '../style/icons/reinit.svg';\n//const reinit_icon = new LabIcon({name: 'test', svgstr: reinit})\nconst verbose = true;\nclass ReInit {\n    constructor(app, nbtracker, mainmenu) {\n        this.command_id_new_empty_scene = 'cell-autorun-kernel-restart:new-scene';\n        this.command_id_duplicate_scene = 'cell-autorun-kernel-restart:duplicate-scene';\n        this.command_id_rename_scene = 'cell-autorun-kernel-restart:rename-scene';\n        this.command_id_delete_scene = 'cell-autorun-kernel-restart:delete-scene';\n        this.command_id_toggle_init_cell = 'cell-autorun-kernel-restart:toggle-initcell';\n        this.command_id_do_reinit = 'cell-autorun-kernel-restart:do-reinit';\n        if (verbose)\n            console.log('Called constructor of ReInit');\n        this.app = app;\n        this.nbtracker = nbtracker;\n        this.mainmenu = mainmenu;\n        this.submenu = null;\n    }\n    initialize() {\n        this.setupGlobalCommands();\n        this.setupReinitMenu();\n        // connect some callbacks\n        this.nbtracker.widgetAdded.connect((sender, nbpanel) => { this.onNotebookTabAdded(nbpanel); });\n        this.nbtracker.currentChanged.connect((sender, nbpanel) => { this.onActiveNotebookChanged(nbpanel); });\n    }\n    /** ****************************************************************************************************************************************\n     * Internal Helper Methods\n     */\n    // **** setup helpers **********************************************************************************************************************\n    setupReinitMenu() {\n        const reinit_menu = new Menu({ commands: this.app.commands });\n        reinit_menu.title.label = 'ReInit';\n        reinit_menu.addItem({ command: this.command_id_do_reinit });\n        reinit_menu.addItem({ command: this.command_id_toggle_init_cell });\n        reinit_menu.addItem({ type: 'separator' });\n        reinit_menu.addItem({ command: this.command_id_new_empty_scene });\n        reinit_menu.addItem({ command: this.command_id_duplicate_scene });\n        reinit_menu.addItem({ command: this.command_id_rename_scene });\n        reinit_menu.addItem({ command: this.command_id_delete_scene });\n        reinit_menu.addItem({ type: 'separator' });\n        this.submenu = new Menu({ commands: this.app.commands });\n        reinit_menu.addItem({ type: 'submenu', submenu: this.submenu });\n        this.mainmenu.addMenu(reinit_menu);\n        this.updateSceneMenu();\n    }\n    setupGlobalCommands() {\n        // setup all commands this.command_id_* including key bindings\n        this.app.commands.addCommand(this.command_id_do_reinit, {\n            label: 'Restart kernel and launch init cells',\n            execute: () => { this.doReInit(); }\n        });\n        this.app.commands.addKeyBinding({\n            command: this.command_id_do_reinit,\n            args: {},\n            keys: ['Accel 0', 'Accel 0'],\n            selector: '.jp-Notebook'\n        });\n        this.app.commands.addCommand(this.command_id_toggle_init_cell, {\n            label: 'Toggle Init Cell',\n            execute: () => { this.toggleInitCell(); }\n        });\n        this.app.commands.addKeyBinding({\n            command: this.command_id_toggle_init_cell,\n            args: {},\n            keys: ['Accel I'],\n            selector: '.jp-Notebook'\n        });\n        this.app.commands.addCommand(this.command_id_new_empty_scene, {\n            label: 'Duplicate Present Scene',\n            execute: () => { this.newEmptyScene(); }\n        });\n        this.app.commands.addCommand(this.command_id_duplicate_scene, {\n            label: 'Duplicate Present Scene',\n            execute: () => { this.duplicatePresentScene(); }\n        });\n        this.app.commands.addCommand(this.command_id_rename_scene, {\n            label: 'Rename Present Scene',\n            execute: () => { this.renamePresentScene(); }\n        });\n        this.app.commands.addCommand(this.command_id_delete_scene, {\n            label: 'Delete Present Scene',\n            execute: () => { this.deletePresentScene(); }\n        });\n    }\n    // **** access to ReInit metadata **********************************************************************************************************\n    // TODO: some initialization/update widget problem???\n    addDefaultReinitDataCellIfNotPresent(nbpanel) {\n        if (nbpanel.content.model) {\n            const cell0 = nbpanel.content.widgets[0];\n            if (!cell0 || !cell0.model.metadata.get('reinit_data')) {\n                if (verbose)\n                    console.log('Adding default ReInit Data Cell');\n                var reinit_cell = new CellModel({\n                    cell: { cell_type: 'raw', source: ['ReInit Data Cell'], metadata: { reinit_data: true, scenes: ['Default Scene'], present_scene: 'Default Scene' } }\n                });\n                nbpanel.content.model.cells.insert(0, reinit_cell);\n                nbpanel.content.update(); // doesn't seem to help\n            }\n        }\n        else {\n            console.error('Could not add default ReInit Data Cell');\n        }\n    }\n    getCurrentNotebookReinitDataCell() {\n        var _a;\n        if (verbose)\n            console.log('getCurrentNotebookReinitDataCell', (_a = this.nbtracker.currentWidget) === null || _a === void 0 ? void 0 : _a.context.path);\n        const nbpanel = this.nbtracker.currentWidget;\n        if (!nbpanel)\n            return null;\n        this.addDefaultReinitDataCellIfNotPresent(nbpanel);\n        let datacell = nbpanel.content.widgets[0];\n        if (!datacell.model.metadata.get('reinit_data')) {\n            console.error('inconsistent reinit data');\n            return null;\n        }\n        return datacell;\n    }\n    getCurrentNotebookSceneList() {\n        const datacell = this.getCurrentNotebookReinitDataCell();\n        if (!datacell)\n            return null;\n        return datacell.model.metadata.get('scenes');\n    }\n    getCurrentNotebookPresentScene() {\n        var _a;\n        const datacell = this.getCurrentNotebookReinitDataCell();\n        if (!datacell)\n            return null;\n        const scene_list = this.getCurrentNotebookSceneList();\n        if (scene_list == null || scene_list.length == 0) {\n            console.error('scene_list is empty');\n            return null;\n        }\n        const present_scene = (_a = datacell.model.metadata.get('present_scene')) === null || _a === void 0 ? void 0 : _a.toString();\n        if (!present_scene) {\n            return scene_list[0];\n        }\n        else {\n            return present_scene;\n        }\n    }\n    setCurrentNotebookPresentScene(scene_name) {\n        const datacell = this.getCurrentNotebookReinitDataCell();\n        if (!datacell)\n            return;\n        const scene_list = this.getCurrentNotebookSceneList();\n        if (scene_list == null || scene_list.length == 0) {\n            console.error('scene_list is empty');\n            return;\n        }\n        if (!scene_list.includes(scene_name)) {\n            console.error('scene not in scene_list');\n        }\n        datacell.model.metadata.set('present_scene', scene_name);\n    }\n    setCurrentNotebookSceneList(scene_list) {\n        const datacell = this.getCurrentNotebookReinitDataCell();\n        if (!datacell)\n            return;\n        datacell.model.metadata.set('scenes', scene_list);\n    }\n    // **** various ****************************************************************************************************************************\n    updateSceneMenu() {\n        if (!this.submenu)\n            return;\n        this.submenu.title.label = 'Present Scene: <none>';\n        this.submenu.clearItems();\n        const scene_list = this.getCurrentNotebookSceneList();\n        const present_scene = this.getCurrentNotebookPresentScene();\n        if (scene_list == null)\n            return;\n        this.submenu.title.label = 'Present Scene: ' + present_scene;\n        for (const scene_name of scene_list) {\n            const command_id = this.ensureSceneActivationCommandExistsAndReturnCommandId(scene_name);\n            this.submenu.addItem({ command: command_id });\n        }\n    }\n    ensureSceneActivationCommandExistsAndReturnCommandId(scene) {\n        const command_id = 'init_scene_activate__' + scene;\n        if (!this.app.commands.hasCommand(command_id)) {\n            this.app.commands.addCommand(command_id, {\n                label: scene,\n                isToggled: () => { return scene == this.getCurrentNotebookPresentScene(); },\n                execute: () => {\n                    this.setCurrentNotebookPresentScene(scene);\n                    this.updateInitCellDots();\n                }\n            });\n        }\n        return command_id;\n    }\n    updateInitCellDots() {\n    }\n    /** ****************************************************************************************************************************************\n     * Callbacks\n     */\n    // **** handle own commands ****************************************************************************************************************\n    doReInit() {\n    }\n    toggleInitCell() {\n    }\n    newEmptyScene() {\n    }\n    duplicatePresentScene() {\n        const present_scene = this.getCurrentNotebookPresentScene();\n        if (!present_scene)\n            return;\n        const old_scene_list = this.getCurrentNotebookSceneList();\n        if (!old_scene_list)\n            return;\n        const nbpanel = this.nbtracker.currentWidget;\n        if (!nbpanel)\n            return;\n        InputDialog.getText({ title: 'Name of the new scene:' }).then(new_scene => {\n            if (!new_scene.value)\n                return;\n            const new_scene_list = Object.assign([], old_scene_list); // copy old_scene_list over\n            new_scene_list.push(new_scene.value);\n            this.setCurrentNotebookSceneList(new_scene_list);\n            // set the init_scene__* tags for the new scene\n            const md_tag_old = 'init_scene__' + present_scene;\n            const md_tag_new = 'init_scene__' + new_scene.value;\n            const notebook = nbpanel.content;\n            notebook.widgets.map((cell) => {\n                if (!!cell.model.metadata.get(md_tag_old)) {\n                    cell.model.metadata.set(md_tag_new, true);\n                }\n            });\n            this.updateSceneMenu();\n        });\n    }\n    renamePresentScene() {\n    }\n    deletePresentScene() {\n    }\n    // **** react to jupyterlab UI events ******************************************************************************************************\n    onNotebookTabAdded(nbpanel) {\n        // this is called whenever a new tab for a notebook is opened (includes a new view)\n        if (verbose)\n            console.log('Got new notebook tab for path:', nbpanel.context.path);\n    }\n    onActiveNotebookChanged(nbpanel) {\n        if (!nbpanel)\n            return;\n        if (verbose)\n            console.log('Changed active notebook tab:', nbpanel.context.path);\n        this.updateSceneMenu();\n    }\n}\n/*\nconst INITCELL_ENABLED_CLASS = 'cell-autorun-kernel-restart-enabled';\n\n\n\nclass KernelReInitButton extends ToolbarButton {\n\n  app: JupyterFrontEnd;\n  nbtracker: INotebookTracker;\n  mainmenu: IMainMenu;\n  submenu: Menu | null;\n\n  kernel_status_listener_connected: boolean;\n  init_on_connect_stage: 'ignore reconnect' | 0 | 1;\n\n  constructor(app: JupyterFrontEnd, nbtracker: INotebookTracker, mainmenu: IMainMenu) {\n    super({onClick: () => { this.onReInitButtonClicked(); }, icon: reinit_icon, tooltip: 'Restart kernel and launch init cells'});\n\n    this.app = app;\n    this.nbtracker = nbtracker;\n    this.mainmenu = mainmenu;\n    this.submenu = null;\n\n    this.kernel_status_listener_connected = false;\n\n    this.init_on_connect_stage = 'ignore reconnect';\n  }\n\n  attach(nbpanel: NotebookPanel) {\n    return\n    const toolbar = nbpanel.toolbar;\n    let insertionPoint = 7;\n\n    toolbar.insertItem(insertionPoint + 1, 'reinit_button', this);\n\n    this.setupContextMenu();\n    this.setupRestartCommand();\n    this.setupMainMenu();\n\n    nbpanel.context.sessionContext.ready.then(() => { this.onAllCellsInNotebookReady(nbpanel); });\n  }\n\n  \n  \n\n  \n\n  private setReinitDataCellStyle(nbpanel: NotebookPanel) {\n      this.getReinitDataCell(nbpanel).hide();\n  }\n\n  private getPresentScene(nbpanel: NotebookPanel) {\n    return this.getReinitDataCell(nbpanel).model.metadata.get('present_scene');\n  }\n\n  \n\n  \n\n  private renamePresentScene() {\n    const nbpanel = this.nbtracker.currentWidget;\n    if(nbpanel) {\n\n      const present_scene = this.getPresentScene(nbpanel);\n      InputDialog.getText({title:'Name of the duplicated scene:'}).then(new_scene => {\n        if(new_scene.value) {\n\n          const old_scene_list = this.getReinitDataCell(nbpanel).model.metadata.get('scenes');\n          const new_scene_list: string[] = [];\n          for(let scene of old_scene_list as string[]) {\n            if(scene != present_scene) {\n              new_scene_list.push(scene);\n            }\n          }\n          new_scene_list.push(new_scene.value);\n          this.getReinitDataCell(nbpanel).model.metadata.set('scenes', new_scene_list);\n\n          const md_tag_old = 'init_scene__' + present_scene;\n          const md_tag_new = 'init_scene__' + new_scene.value;\n          const notebook = nbpanel.content;\n          notebook.widgets.map((cell: Cell) => {\n            if(!!cell.model.metadata.get(md_tag_old)) {\n              cell.model.metadata.set(md_tag_new, true);\n              cell.model.metadata.delete(md_tag_old);\n            } else {\n              cell.model.metadata.set(md_tag_new, false);\n              cell.model.metadata.delete(md_tag_old);\n            }\n          });\n\n          this.updateScenesInMenu(nbpanel);\n\n        }\n      });\n    }\n  }\n\n  private deletePresentScene() {\n    const nbpanel = this.nbtracker.currentWidget;\n    if(nbpanel) {\n\n      const present_scene = this.getPresentScene(nbpanel);\n\n      const old_scene_list = this.getReinitDataCell(nbpanel).model.metadata.get('scenes');\n      const new_scene_list: string[] = [];\n      for(let scene of old_scene_list as string[]) {\n        if(scene != present_scene) {\n          new_scene_list.push(scene);\n        }\n      }\n      this.getReinitDataCell(nbpanel).model.metadata.set('scenes', new_scene_list);\n\n      const md_tag_old = 'init_scene__' + present_scene;\n      const notebook = nbpanel.content;\n      notebook.widgets.map((cell: Cell) => {\n        if(!!cell.model.metadata.get(md_tag_old)) {\n          cell.model.metadata.delete(md_tag_old);\n        } else {\n          cell.model.metadata.delete(md_tag_old);\n        }\n      });\n\n      this.updateScenesInMenu(nbpanel);\n    }\n  }\n\n\n\n  \n\n  private setCellStyles(nbpanel: NotebookPanel) {\n\n    if(this.nbtracker.currentWidget) {\n      const md_tag = 'init_scene__';\n      const present_scene = this.getPresentScene(this.nbtracker.currentWidget);\n      const md_tag_ext = md_tag + present_scene;\n\n      const notebook = nbpanel.content;\n      notebook.widgets.map((cell: Cell) => {\n        if(!!cell.model.metadata.get(md_tag_ext)) {\n          cell.addClass(INITCELL_ENABLED_CLASS);\n        } else {\n          cell.removeClass(INITCELL_ENABLED_CLASS);\n        }\n      });\n    }\n  }\n\n  private setupContextMenu() {\n\n    const command_id = 'cell-autorun-kernel-restart:toggle-autorun';\n\n    this.app.contextMenu.addItem({\n      command: command_id,\n      selector: '.jp-Cell',\n      rank: 501\n    });\n  }\n\n \n\n  private async doKernelInitialization() {\n\n    const md_tag = 'init_scene__';\n    \n    if(this.nbtracker.currentWidget) {\n      const present_scene = this.getPresentScene(this.nbtracker.currentWidget);\n      const md_tag_ext = md_tag + present_scene;\n      console.log('executing all cell with tag', md_tag_ext)\n\n      const notebook = this.nbtracker.currentWidget.content;\n      const notebookPanel = this.nbtracker.currentWidget;\n\n      notebook.widgets.map((cell: Cell) => {\n\n        if(!!cell.model.metadata.get(md_tag_ext)) {\n          if(cell.model.type == 'code') {\n            CodeCell.execute(cell as CodeCell, notebookPanel.sessionContext);\n          }\n        }\n\n      });\n    }\n  }\n\n  \n\n  toggleInitCell() {\n\n    const cell = this.nbtracker.activeCell;\n    const md_tag = 'init_scene__';\n\n    if(this.nbtracker.currentWidget && cell) {\n      const present_scene = this.getPresentScene(this.nbtracker.currentWidget);\n      const md_tag_ext = md_tag + present_scene;\n\n      if(!cell.model.metadata.get(md_tag_ext)) {\n        cell.model.metadata.set(md_tag_ext, true)\n        cell.addClass(INITCELL_ENABLED_CLASS);\n      } else {\n        cell.model.metadata.set(md_tag_ext, false)\n        cell.removeClass(INITCELL_ENABLED_CLASS);\n      }\n\n    }\n  }\n\n  onAllCellsInNotebookReady(nbpanel: NotebookPanel) {\n    this.addDefaultReinitDataCellIfNotPresent(nbpanel);\n    this.setReinitDataCellStyle(nbpanel);\n    this.updateScenesInMenu(nbpanel);\n\n    this.setCellStyles(nbpanel);\n  }\n\n  onReInitButtonClicked() {\n\n    if(!this.kernel_status_listener_connected) {\n      this.nbtracker.currentWidget?.context.sessionContext.session?.kernel?.connectionStatusChanged.connect((_unused, conn_stat) => {\n        this.kernelConnectionStatusListener(conn_stat);\n      });\n      this.kernel_status_listener_connected = true;\n    }\n    this.init_on_connect_stage = 0;\n    this.nbtracker.currentWidget?.context.sessionContext.session?.kernel?.restart();\n  }\n\n  kernelConnectionStatusListener(conn_stat: ConnectionStatus) {\n    \n    if(this.init_on_connect_stage == 'ignore reconnect') {\n      return;\n    }\n\n    if(this.init_on_connect_stage == 0 && conn_stat == 'connecting') {\n      this.init_on_connect_stage = 1;\n      return;\n    }\n\n    if(this.init_on_connect_stage == 1 && conn_stat == 'connected') {\n      this.doKernelInitialization();\n      this.init_on_connect_stage = 'ignore reconnect';\n      return;\n    }\n  }\n}\n\n*/\n/**\n * Initialization data for the jupyterlab_cell_autorun_kernel_restart extension.\n */\nconst plugin = {\n    id: 'cell-autorun-kernel-restart',\n    autoStart: true,\n    requires: [INotebookTracker, IMainMenu],\n    activate: (app, nbtracker_, mainmenu) => {\n        const reinit_obj = new ReInit(app, nbtracker_, mainmenu);\n        reinit_obj.initialize();\n    }\n};\nexport default plugin;\n"],"names":[],"sourceRoot":""}