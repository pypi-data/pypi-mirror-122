import abc
import json
import os
import signal
import subprocess
import tempfile
import uuid
from typing import Any, Dict, Union, Tuple, Optional, Set, Callable, List

import jwt
import stringcase
import logging

import tailer as tailer
from django_cbim_general_service.conf import settings
from django_app_graphql.graphene.tests.AbstractGraphQLTestMixin import AbstractGraphQLTestMixin, GraphQLResponseInfo
from django_app_graphql.graphene.tests.testcases import AbstractGraphQLRealStaticLiveServerTestCase


LOG = logging.getLogger(__name__)


class AbstractCBIMGraphQLTest(AbstractGraphQLRealStaticLiveServerTestCase):
    """
    A graphql test that is agumented with functions useful in cbim projects.

    Since CBIM needs to setup a federation gateway in order to test correctly, this class will automatically deploy one.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        cls = type(self)
        # update graphql url and port with the values in the instance methods
        cls.GRAPHQL_URL = self.graphql_url()
        cls.port = self.service_to_test_port()

    # GRAPHQL_URL = f"http://127.0.0.1:3000/graphql"
    # port = AbstractCBIMGraphQLTest.service_to_test_port()

    @abc.abstractmethod
    def service_to_test_port(self) -> int:
        pass

    def federation_gateway_name(self) -> str:
        """
        The default implementation assumes that there is such a project as sibling direcotry of the project under test.
        Generally speaking, there you should be able to run "npm run start".

        :return: the path where an apollo federation npm project is located
        """
        return os.path.join(settings.BASE_DIR, os.pardir, "apollo-federation")

    def gateway_hostname(self) -> str:
        return "127.0.0.1"

    def gateway_port(self) -> int:
        return 3000

    def graphql_url(self) -> str:
        return f"http://{self.gateway_hostname()}:{self.gateway_port()}/graphql"

    @abc.abstractmethod
    def service_name(self) -> str:
        """
        Name of the service we are testing
        """
        pass

    def local_service_login_mutation_name(self) -> str:
        return f"{stringcase.camelcase(self.service_name())}Login"

    def local_service_api_token_resolver_name(self) -> str:
        return f"{stringcase.camelcase(self.service_name())}ApiToken"

    def local_service_user_resolver_name(self) -> str:
        return f"{stringcase.camelcase(self.service_name())}User"

    def local_service_user_me_query_name(self) -> str:
        return f"{stringcase.camelcase(self.service_name())}UserMe"

    def local_service_user_permission_resolver_name(self) -> str:
        return f"{stringcase.camelcase(self.service_name())}Permissions"

    def perform_authentication_on_user_auth_service(self, username: str, password: str) -> Tuple[GraphQLResponseInfo, str]:
        """
        Perform authentication by contacting first user-auth-service

        :param username: username used to contact the uer-auth-service
        :param password: password of the username
        :return: tuple where the first value is the output of the graphql query whil the secondi s the access_token generated by the user-auth-service
        """
        response = self.perform_simple_mutation(f"""       
        mutation loginToUserAuthService {{
              userAuthLogin(username: "{username}", password: "{password}") {{
                token
              }}
            }}
        """)
        self.assert_graphql_response_noerrors(response)
        self.assert_json_path_exists(response, "data.userAuthLogin.token")
        self.assert_json_path_str_longer_than(response, "data.userAuthLogin.token", minimum_length=10)  # the access token is usually very long
        return response, response.content["data"]["userAuthLogin"]["token"]

    def perform_authentication_on_local_service(self, access_token: str) -> Tuple[GraphQLResponseInfo, str]:
        """
        Perform authentication by contacting the CBIM service we are developing right now

        :param access_token: access token generate by the user-auth-service
        :return: tuple where the first value is the output of the graphql query while the second is the api_token generated by the developing service
        """
        response = self.perform_simple_mutation(f"""       
                mutation loginToUserDevelopingService {{
                      {self.local_service_login_mutation_name()}(access_token: "{access_token}") {{
                        {self.local_service_api_token_resolver_name()}
                      }}
                    }}
                """)
        self.assert_graphql_response_noerrors(response)
        self.assert_json_path_exists(response, f"data.{self.local_service_login_mutation_name()}.{self.local_service_api_token_resolver_name()}")
        self.assert_json_path_str_longer_than(response, f"data.{self.local_service_login_mutation_name()}.{self.local_service_api_token_resolver_name()}",
                                         minimum_length=10)  # the access token is usually very long
        return response, response.content["data"][self.local_service_login_mutation_name()][self.local_service_api_token_resolver_name()]

    def ensure_federation_work(self, username: str, password: str):
        response = self.perform_simple_mutation(f"""       
            mutation loginToUserAuthService {{
                userAuthLogin(username: "{username}", password: "{password}") {{
                token
                user {{
                  id
                  groups {{
                    id
                    name
                  }}
                }}
                }}
            }}
        """)
        self.assert_graphql_response_noerrors(response)
        self.assert_json_path_exists(response, "data.userAuthLogin.token")
        self.assert_json_path_str_longer_than(response, "data.userAuthLogin.token", minimum_length=10)  # the access token is usually very long
        access_token = response.content["data"]["userAuthLogin"]["token"]
        response = self.perform_simple_mutation(f"""
            mutation {{
                {self.local_service_login_mutation_name()}(accessToken: "{access_token}") {{
                    {self.local_service_api_token_resolver_name()}
                    {self.local_service_user_resolver_name()} {{
                        id
                        username
                        groups {{
                            id
                            name
                        }}
                        {self.local_service_user_permission_resolver_name()} {{
                            id
                            codename
                        }}
                    }}
                }}
            }}""")
        self.assert_graphql_response_noerrors(response)
        self.assert_json_path_exists(response, f"data.{self.local_service_login_mutation_name()}.{self.local_service_api_token_resolver_name()}")
        self.assert_json_path_str_longer_than(response, f"data.{self.local_service_login_mutation_name()}.{self.local_service_api_token_resolver_name()}", minimum_length=10)  # the access token is usually very long
        api_token = response.content["data"][self.local_service_login_mutation_name()][self.local_service_api_token_resolver_name()]

        response = self.perform_simple_query(f"""
            query me {{
              {self.local_service_user_me_query_name()}(apiToken: "{api_token}") {{
                id
                groups {{
                  id
                  name
                }}
                {self.local_service_user_permission_resolver_name()} {{
                  id
                  codename
                }}
              }}
            }}
        """)
        self.assert_graphql_response_noerrors(response)

    def perform_authentication(self, **kwargs) -> any:
        _, result, _, _, _, _ = self.perform_cbim_authentication(username=kwargs["username"], password=kwargs["password"])
        return result

    def perform_cbim_authentication(self, username: str, password: str) -> Tuple[str, str, any, any, GraphQLResponseInfo, GraphQLResponseInfo]:
        """
        Perform the steps necessary for a general service to be correctly authenticated

        :param username: username used to contact the uer-auth-service
        :param password: password of the username
        :return:
            - access token
            - api token
            - content of acces token, decoded without verifying the token
            - content of api token, decoded without verifying the token
            - reponse of user-auth-service
            - response of local service
        """

        response_1, access_token = self.perform_authentication_on_user_auth_service(username, password)
        response_2, api_token = self.perform_authentication_on_local_service(access_token)

        # we fetch the jwt content without validating. Required since we want to read the jwt content
        # see https://pyjwt.readthedocs.io/en/stable/usage.html#reading-the-claimset-without-validation
        access_token_payload = jwt.decode(access_token, options={"verify_signature": False})
        api_token_payload = jwt.decode(api_token, options={"verify_signature": False})

        return access_token, api_token, access_token_payload, api_token_payload, response_1, response_2

    # ##################################################
    # START AND STOP APOLLO FEDERATION
    # ##################################################

    def setUp(self) -> None:
        super().setUp()

        cls = type(self)
        if not hasattr(cls, "federation_gateway_success"):
            rnd = uuid.uuid1()
            cls.federation_gateway_stdout_filepath = os.path.abspath(
                os.path.join(tempfile.gettempdir(), f"federation_gateway-{rnd}"))
            cls.federation_gateway_stdout_file = open(cls.federation_gateway_stdout_filepath, encoding="utf8", mode="wt")
            LOG.info(
                f"Starting federation gateway, located at {self.federation_gateway_name()}. stdout is in file {cls.federation_gateway_stdout_filepath}")
            cls.federation_gateway_process = subprocess.Popen(
                # command.
                ["npm", "run", "start", "--", "--port", str(self.gateway_port()) ],
                shell=True,
                # writeable input stream
                universal_newlines=True, stdin=subprocess.PIPE,
                # readable stdout inside a file
                stdout=cls.federation_gateway_stdout_file,
                # stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                encoding="utf8",
                # cwd
                cwd=self.federation_gateway_name()
            )
            # DO NOT PUT BREAKPOINT BETWEEN THE POPEN AND THE FOR LOOP! Otherwise tail will not detect the first lines
            # We need to wait some time before the federation gateway is on. We do it by making sure that the server
            # print a particular line on the gateway when it is ready. Then, we poll the stdout
            # for line in cls.federation_gateway_stdout.file, encoding="utf8", mode="rt")):
            f_to_watch = open(cls.federation_gateway_stdout_filepath, encoding="utf8", mode="rt")
            for line in tailer.follow(f_to_watch):
                # Server ready!
                if line is None:
                    continue
                if isinstance(line, bytes):
                    line = line.decode("utf8")
                line = str(line)
                line = line.rstrip("\n")
                if len(line) == 0:
                    continue
                LOG.info(line)
                if "Couldn't load service definitions for" in line:
                    raise ValueError(f"We detected that the federation gateway could not be started! line={line}")
                if "Server ready at " in line:
                    LOG.info(f"SPECIAL LINE DETECTED. Break.")
                    break
            # close file
            f_to_watch.close()
            # the server may have been abrutively closed
            cls.federation_gateway_process.poll()
            if cls.federation_gateway_process.returncode is not None and cls.federation_gateway_process.returncode != 0:
                raise ValueError(
                    f"We detected that the server has been abrutively closed. return code: {cls.federation_gateway_process.returncode}")
            LOG.info(f"Federation has successfully started!")
            cls.federation_gateway_success = True

    @classmethod
    def tearDownClass(cls):
        super().tearDownClass()
        if hasattr(cls, "federation_gateway_success") and cls.federation_gateway_process is not None:
            LOG.info(f"Killing federation gateway process...")
            # we cannot simply kill the program. We need to send a Ctrl+C signal,
            # an then inputs the confirmation button (y\n)
            # otherwise opened socket will leak
            cls.federation_gateway_process.send_signal(signal.CTRL_C_EVENT)
            # check if the process is still up
            if cls.federation_gateway_process.poll() is not None:
                LOG.info(f"Done Killing federation gateway process (did not send signal)")
            else:
                try:
                    cls.federation_gateway_process.communicate(input="Y\n", timeout=1)[0]
                except subprocess.TimeoutExpired:
                    LOG.info(f"""We have waited some time for the process to accept our termination signal, 
                        but with no result. Assuming the process is terminated""")
                else:
                    # now we need to wait for termination
                    while True:
                        try:
                            LOG.info(f"Waiting for process {cls.federation_gateway_process} to terminate...")
                            cls.federation_gateway_process.wait(0.5)
                            LOG.info(f"""process {cls.federation_gateway_process} successfully terminated
                                with {cls.federation_gateway_process.returncode}""")
                            break
                        except subprocess.TimeoutExpired:
                            pass
                    LOG.info(f"Done Killing federation gateway process")
            # closing stdout file
            cls.federation_gateway_stdout_file.close()
        cls.federation_gateway_process = None

    # ################################################################à
    # TESTS
    # ################################################################à

    def test_ok(self):
        LOG.info(f"Always correct test!")

    def test_federation__authentication(self):
        LOG.info(f"Testing if the authentication works...")
        self.ensure_federation_work(username="reportMOH", password="Password0!")